/*
Copyright (c) 2020-21 Project re-Isearch and its contributors: See CONTRIBUTORS.
It is made available and licensed under the Apache 2.0 license: see LICENSE
*/
////////////////////////////////////////////////////////////////////////////////////////////
////////////// TO CONFIGURE   //////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

const char *  _IB_SUPPORT_EMAIL_ADDRESS = "edz@nonmonotonic.net (Edward C. Zimmermann)";
const char *  _IB_REG_ADDR = "edz@nonmonotonic.net";
const char *  _IB_HTDOCS_HOME = "http://www.nonmonotonic.net/re:search/";

////////////////////////////////////////////////////////////////////////////////////////////

const char * _IB_INI_MAGIC = "\
; [@@ re:iSearch @@]\n\
; This .INI file is used by re:iSearch v.1 [fomerly IB Engine v.3] libs.\n\
; Warning: This file is automatically generated and volatile. It should\n\
; not be edited. Consult the documentation for modification instructions.\n";


#include "platform.h"
#include "pathname.hxx"

#include <stdlib.h>
#include <errno.h>

#if defined(_WIN32)
# include <winsock2.h>
#else
# include <pwd.h>
#endif

#include "common.hxx"

static const int  _ini_version = 3;
static const char *service_admin = "asfadmin";
static const char *ib_admin      = "ibadmin";
static const char *ib_context        = "$CommonFilesDir/nonmonotonic";
static const char *ib_libcontext     = "/opt/nonmonotonic";
static const char *ib_var_libcontext = "/var/opt/nonmonotonic";

#if defined(_MSDOS) || defined(_WIN32)
static const char dot_ib[] = "_ib";
extern STRING __ExpandPath(const STRING& filePath);
//extern STRING FindSharedLibrary(const STRING& Argv0 = NulString);

#else /* UNIX */
static const char dot_ib[] = ".ib";
#endif

extern const char *_GetUserHome(const char *user);


STRING ResolveBinPath(const STRING& Filename)
{
  if (Filename.IsEmpty() || IsAbsoluteFilePath(Filename))
    return Filename;

  if (ExeExists(Filename)) {
    // Exists but not absolute.. so
    return ExpandFileSpec(Filename);
  }

  if (_ib_ResolveBinPath)
    {
      STRING tmp;
      int    tmpLen = 0;
      int    l      = -1;
      while (l < 0)
	{
	  tmpLen += 1024;
	  if ((l = _ib_ResolveBinPath(Filename.c_str(), tmp.GetWriteBuf(tmpLen), tmpLen)) > 0)
	    {
	      tmp.EraseAfterNul(l);
	      return tmp;
	    }
	}
    }
#ifdef _WIN32
/*
 * We should look 
 * 	1. where we the executable is
 * 	2. where the dll is
 * 	3. in CommonFilesDir
 * 
*/
  STRING tmp (FindExecutable(Filename));

  if (tmp.GetLength() && ExeExists(tmp)) return tmp;

  STRING dir;
  STRING exe (RemovePath(tmp));

  // Not found? Look relative to the shared library
  if ((tmp = FindSharedLibrary()).GetLength())
    {
      dir = RemoveFileName (tmp);
      if(FixMicrosoftPathNames(tmp.form("%s/bin/%s", dir.c_str(), Filename.c_str())))
	return tmp;
      if(Exists(FixMicrosoftPathNames(tmp.form("%s/%s", dir.c_str(), Filename.c_str()))))
	return tmp;
    }

  dir = __ExpandPath( ib_context  );
  if(!exe.IsEmpty() && !dir.IsEmpty())
    {
      if (Exists(FixMicrosoftPathNames(tmp.form("%s/%s/%s", dir.c_str(), exe.c_str(), Filename.c_str()))))
	return tmp;
      if(Exists(FixMicrosoftPathNames(tmp.form("%s/bin/%s", dir.c_str(), Filename.c_str()))))
	return tmp;
    }
  if ((dir = __ExpandPath("$CommonFilesDir")).GetLength())
    {
      if(Exists(FixMicrosoftPathNames(tmp.form("%s/bin/%s", dir.c_str(), Filename.c_str()))))
	return tmp;
    }
#else /* UNIX */

  STRING tmp;

  for (int state = 0; state <= 4; state++) {
    const char     *dir = NULL;
    switch (state) {
    case 0:
	if ((dir = _GetUserHome(service_admin)) != NULL && *dir)
	  break; // Have something
	state++;
    case 1:
	if ((dir = _GetUserHome(ib_admin)) != NULL && *dir)
	  break;
	state++;
    case 2:
	dir = ib_libcontext; 
	break;
    case 3:
	dir = "/opt";
	break;
    case 4:
	dir = "/usr";
	break;
#if 0
    case 5:
	dir = "..";
	break;
#endif
    } // switch
    // Look into process-id home
    if (dir)
      {
	static const char format[] =  "Can't access %s";
	errno = 0;
	if (Exists(tmp.form("%s/bin/%s", dir, Filename.c_str())))
	   return tmp;
	if (errno ==  EACCES
#ifdef ENOLINK
 || errno == ENOLINK
#endif
 	|| errno == EBUSY )
	   message_log (LOG_ERRNO, format, tmp.c_str());
	errno = 0;
        if (IsExecutable(tmp.form("%s/contrib/%s", dir, Filename.c_str())))
          return tmp;
        if (errno ==  EACCES
#ifdef ENOLINK
 || errno == ENOLINK
#endif
	|| errno == EBUSY)
          message_log (LOG_ERRNO, format, tmp.c_str());
	errno = 0;
	if (IsExecutable (tmp.form("%s/contrib/bin/%s", dir, Filename.c_str())))
	  return tmp;
	if (errno ==  EACCES
#ifdef ENOLINK
	 || errno == ENOLINK
#endif
	|| errno == EBUSY )
	  message_log (LOG_ERRNO, format, tmp.c_str());
	if (IsExecutable (tmp.form("%s/local/bin/%s", dir, Filename.c_str())))
	  return tmp;
      }
  } // for()
  /* NOT FOUND */
#endif
  return Filename;
}


STRING ResolveConfigPath(const STRING& Filename)
{
  if (Filename.IsEmpty() || IsAbsoluteFilePath(Filename))
    return Filename;

  if (_ib_ResolveConfigPath)
    {
      STRING tmp;
      int    tmpLen = 0;
      int    l      = -1;
      while (l < 0)
	{
	  tmpLen += 1024;
	  if ((l = _ib_ResolveConfigPath(Filename.c_str(), tmp.GetWriteBuf(tmpLen), tmpLen)) > 0)
	    {
	      tmp.EraseAfterNul(l);
	      message_log(LOG_DEBUG, "Configuration %s --> %s", Filename.c_str(), tmp.c_str());
	      return tmp;
	    }
	}
    }

#ifdef _WIN32
/*
 * We should look 
 * 	1. where we the executable is
 * 	2. where the dll is
 * 	3. in CommonFilesDir
 * 
 * ????????????????????????????????????????????????????????????????????????
 * EDZ: Pls make up your mind, where you want to find config files in
 * 		a windows enfironment an make your changes
*/

  STRING tmp (FindExecutable());
  STRING exe (RemovePath(tmp) );
  STRING dir (RemoveFileName(tmp));

  if(!dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/conf/%s", dir.c_str(), Filename.c_str()))))
	return tmp;

  if(!dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s", dir.c_str(), Filename.c_str()))))
	return tmp;

  if (!(dir = RemoveFileName (FindSharedLibrary())).IsEmpty() && DirectoryExists(dir))
    {
      if (Exists(FixMicrosoftPathNames(tmp.form("%s/%s", dir.c_str(), Filename.c_str()))))
	return tmp;
    }

  const STRING dll (GlobalSharedLibraryName());

  dir = __ExpandPath( ib_context );
  if(!exe.IsEmpty() && !dll.IsEmpty() &&
	 !dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s/%s/%s", dir.c_str(), exe.c_str(), dll.c_str(), Filename.c_str()))))
	return tmp;

  if(!exe.IsEmpty() &&
	 !dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s/%s", dir.c_str(), exe.c_str(), Filename.c_str()))))
	return tmp;

  if(!dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s", dir.c_str(), Filename.c_str()))))
	return tmp;

  dir = __ExpandPath("$CommonFilesDir");
  if(!exe.IsEmpty() && !dll.IsEmpty() && !dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s/%s/%s", dir.c_str(), exe.c_str(), dll.c_str(), Filename.c_str()))))
	return tmp;

  if(!exe.IsEmpty() && !dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s/conf/%s", dir.c_str(), exe.c_str(), Filename.c_str()))))
	return tmp;

  if(!exe.IsEmpty() && !dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s/%s", dir.c_str(), exe.c_str(), Filename.c_str()))))
	return tmp;

  if(!dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/conf/%s", dir.c_str(), Filename.c_str()))))
	return tmp;

  if(!dir.IsEmpty() && Exists(FixMicrosoftPathNames(tmp.form("%s/%s", dir.c_str(), Filename.c_str()))))
	return tmp;

  return Filename;

#else /* UNIX */
  STRING tmp;

  for (int state = 0; state <= 5; state++) {
    const char     *dir = NULL;

    switch (state) {
    case 0:
      if ((dir = _GetUserHome (NULL)) != NULL && *dir)
	break;
      state++;
    case 1:
      {
	struct passwd  *pwent;
        /* Set UID processes */
        if (getuid() != geteuid() && (pwent = getpwuid(geteuid())) != NULL)
	  {
	    dir = pwent->pw_dir;
	    break;
	  }
      }
	state++;
    case 2:
	if ((dir = _GetUserHome(service_admin)) != NULL && *dir)
	  break;
	state++;
    case 3:
	if ((dir = _GetUserHome(ib_admin)) != NULL && *dir)
	  break;
	state++;
    case 4:
	dir =  ib_var_libcontext; 
	break;
    case 5:
	dir =  ib_libcontext; 
	break;
    } // switch
    // Look into process-id home
    if (dir && *dir)
      {
	static const char format[] =  "Can't access %s";

	if (state < 2) {
	  errno = 0;
	  if (Exists(tmp.form("%s/%s/%s", dir, dot_ib, Filename.c_str())))
	    return tmp;

#ifndef ENOLINK
#define ENOLINK ENODEV
#endif
	  if (errno ==  EACCES || errno == ENOLINK)
	    message_log (LOG_ERRNO, format, tmp.c_str());
	  errno = 0;
	  if (Exists(tmp.form("%s/.%s", dir, Filename.c_str())))
	    return tmp;
	  if (errno ==  EACCES || errno == ENOLINK)
	    message_log (LOG_ERRNO, format, tmp.c_str());
	}
	if (state > 1) {
	  errno = 0;
	  if (Exists(tmp.form("%s/conf/%s", dir, Filename.c_str())))
	    return tmp;
	  if (errno ==  EACCES || errno == ENOLINK)
	    message_log (LOG_ERRNO, format, tmp.c_str());
	  errno = 0;
	  if (Exists(tmp.form("%s/etc/%s", dir, Filename.c_str())))
	    return tmp;
	  if (errno ==  EACCES || errno == ENOLINK)
	    message_log (LOG_ERRNO, format, tmp.c_str());

	}
      }
  } // for()
  /* NOT FOUND */

  message_log(LOG_DEBUG,"Could not resolve %s", Filename.c_str());

  tmp.Clear();
  return tmp;
#endif
}

bool ResolveConfigPath(STRING *Filename)
{
  if (Filename != NULL)
    {
      STRING tmp ( ResolveConfigPath(*Filename) );
      if (Exists(tmp))
	{ 
	  *Filename = tmp;
	  return true;
	}
    }
  return false;
}

#ifndef _WIN32
STRING ResolveHtdocPath(const STRING& Filename, bool AsUrl)
{
  if (Filename.IsEmpty())
    return Filename;

  if (IsAbsoluteFilePath(Filename))
    return AsUrl ? (STRING("file://")+Filename) : Filename;

  STRING tmp;
  for (int state = 0; state <= 3; state++) {
    const char           *dir = NULL;
    switch (state) {
    case 0:
	if ((dir =  _GetUserHome(service_admin)) != NULL && *dir)
	  break;
	state++;
    case 1:
	if ((dir = _GetUserHome(ib_admin)) != NULL && *dir)
	  break;
	state++;
    case 2:
	dir =  ib_var_libcontext;
	break;
    case 3:
	dir = ib_libcontext; 
	break;
    } // switch
    // Look into process-id home
    if (dir)
      {
	static const char format[] =  "Can't access %s";
	errno = 0;
	if (Exists(tmp.form("%s/htdocs/%s", dir, Filename.c_str())))
	  break;
	if (errno ==  EACCES || errno == ENOLINK)
	  message_log (LOG_ERRNO, format, tmp.c_str());
        errno = 0;
        if (Exists(tmp.form("%s/html/%s", dir, Filename.c_str())))
          break;
        if (errno ==  EACCES || errno == ENOLINK)
          message_log (LOG_ERRNO, format, tmp.c_str());
	tmp.Clear();
      }
  } // for()
  if (AsUrl)
    {
      if (tmp.IsEmpty())
	tmp << _IB_HTDOCS_HOME << Filename;
      else
	tmp.Insert(1, "file://");
    }
  else if (tmp.IsEmpty())
    tmp = Filename;
  return tmp;
}
#endif


extern const char * const __IB_StandardBaseDirs[];

const char *_IB_BASEPATH()
{
  static STRING   path;


  if (path.IsEmpty())
    {
      const char *dir;
      STRING exePath (FindExecutable());

      if (exePath.GetLength())
	{
	  path = RemoveFileName (exePath);
	  RemoveTrailingSlash(&path);
	  RemoveFileName(&path);
	  return path.c_str();
	}
#ifndef _WIN32
      // Have we defined a home?
      if ((dir = _GetUserHome(service_admin)) == NULL || !DirectoryExists(dir))
        if ((dir = _GetUserHome(ib_admin)) == NULL || !DirectoryExists(dir))
#endif
	  {
            for (size_t i=0; __IB_StandardBaseDirs[i]; i++)
              {
                if (DirectoryExists(__IB_StandardBaseDirs[i]))
                  {
                    path = __IB_StandardBaseDirs[i];
                    break; // Found something!
                  }
              }
          }
#ifndef _WIN32
	else
	  path = dir;
      else
	path = dir;
#endif
    }
  return path.c_str();
}


const char *_IB_LIBPATH()
{
  const  char * const lib = "/lib";
  static STRING dir;

  if (dir.IsEmpty())
    {
      if ((dir = FindSharedLibrary()).IsEmpty())
	if ((dir = FindExecutable()).IsEmpty())
	  dir = STRING(_IB_BASEPATH()) + lib;
      if (dir.GetLength())
	RemoveFileName(&dir);
     }
#ifdef _WIN32
  return dir.c_str();
#else
  static STRING   path(dir);

  if (path.IsEmpty())
    {
      // Well installed?
      if (DirectoryExists(path =  _IB_BASEPATH()) && DirectoryExists(path+= lib))
	return path.c_str();

      // Have we defined a home?
      path = _GetUserHome(service_admin);
      if (path.IsEmpty() || !DirectoryExists(path+= lib))
	if ((path = _GetUserHome(ib_admin)).IsEmpty() || !DirectoryExists(path+= lib))
	  {
	    for (size_t i=0; __IB_StandardBaseDirs[i]; i++)
	      {
		if (DirectoryExists(path = __IB_StandardBaseDirs[i]) && DirectoryExists(path+= lib))
		  break; // Found something!
	      }
	  }
    }
  return path.c_str();
#endif
}
