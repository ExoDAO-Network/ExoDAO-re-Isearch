#include "platform.h"

#if defined(_MSDOS) || defined(_WIN32)
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>

#define _ALT_PIPE 1

extern void _IB_WarningMessage(const char *);

#if _ALT_PIPE
static int  _my_read_pclose(FILE *fp)
{
  return (fp ? fclose(fp) : -1);
}

static FILE *_my_read_popen(const char *c, const char *mode = "r")
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si =
    {0};
    HANDLE rd, wr;
    SECURITY_ATTRIBUTES sec;
    sec.bInheritHandle = TRUE;
    sec.nLength = sizeof sec;
    sec.lpSecurityDescriptor = 0;
    if (!CreatePipe(&rd, &wr, &sec, 0))
        return 0;
    /* make sure child won't inherit read-end of pipe */
    {
        HANDLE rd_;
        if (!DuplicateHandle(GetCurrentProcess(), rd,
                             GetCurrentProcess(), &rd_, 0, FALSE,
                      DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS))
          {
              CloseHandle(rd);
              CloseHandle(wr);
              return 0;
          }
        rd = rd_;
    }
    si.cb = sizeof si;
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    si.hStdOutput = wr;
    if (!CreateProcess(0, (LPTSTR)c, 0, 0, TRUE, 0, 0, 0, &si, &pi))
      {
          CloseHandle(rd);
          CloseHandle(wr);
          return 0;
      }
    CloseHandle(wr);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    return fdopen(_open_osfhandle( (long)(unsigned long)rd, O_RDONLY | O_TEXT), mode); 
}
#endif

/*------------------------------------------------------------------------------
  Globals for the Routines _IB_popen() / _IB_pclose()
------------------------------------------------------------------------------*/
static HANDLE my_pipein[2]  = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE};
static HANDLE my_pipeout[2] = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE};
static HANDLE my_pipeerr[2] = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE};
static char   my_popenmode = ' ';
static int    instances    = 0;

#define CLOSE_HANDLE(_x_) {CloseHandle (_x_); (_x_) =  INVALID_HANDLE_VALUE; }

static int my_pipe(HANDLE *readwrite)
{
  SECURITY_ATTRIBUTES sa;

  sa.nLength = sizeof(sa);          /* Length in bytes */
  sa.bInheritHandle = 1;            /* the child must inherit these handles */
  sa.lpSecurityDescriptor = NULL;

  if (! CreatePipe (&readwrite[0],&readwrite[1],&sa,1 << 13))
  {
    errno = -1; /* EMFILE; que? */
    return -1;
  }

  return 0;
}

/*------------------------------------------------------------------------------
  Replacement for 'popen()' under WIN32.
  NOTE: if cmd contains '2>&1', we connect the standard error file handle
    to the standard output file handle.
------------------------------------------------------------------------------*/
FILE *_IB_popen(const char *cmd, const char *mode)
{
#if _ALT_PIPE
  if (mode == NULL || cmd == NULL || strchr(cmd, '<') || strchr(cmd, '>') || strchr(cmd, '|'))
    return NULL;
  return _my_read_popen(cmd, mode);
#else

  FILE *fptr = NULL;
  PROCESS_INFORMATION piProcInfo;
  STARTUPINFO siStartInfo;
  int         success, redirect_error = 0;
  char        cmd_buff[2048];
  char       *err2out;
  int         isCmd = 0;
  size_t      cmd_len = 0;
  const char *shell_cmd = getenv ("SHELL");
  const char *shell_base_cmd; 

  if (instances)
    {
      _IB_WarningMessage("Another external pipe is running.");
      return NULL;
    }

  if (shell_cmd == NULL || *shell_cmd == '\0')
    {
      if ((shell_cmd = getenv("COMSPEC")) == NULL || *shell_cmd == '\0')
	shell_cmd = "cmd";
     }
  { const char *tcp;
    if ((tcp = strrchr(shell_cmd, '\\')) == NULL)
      tcp = shell_cmd;
    else
      tcp++;
    if ((shell_base_cmd = strrchr(tcp, '/')) == NULL)
       shell_base_cmd = tcp;
    else shell_base_cmd++;
    if (shell_base_cmd == '\0')
      shell_base_cmd = shell_cmd;
  }

  my_pipein[0]   = INVALID_HANDLE_VALUE;
  my_pipein[1]   = INVALID_HANDLE_VALUE;
  my_pipeout[0]  = INVALID_HANDLE_VALUE;
  my_pipeout[1]  = INVALID_HANDLE_VALUE;
  my_pipeerr[0]  = INVALID_HANDLE_VALUE;
  my_pipeerr[1]  = INVALID_HANDLE_VALUE;

  if (cmd == NULL || *cmd == '\0') goto done;
  if (mode == NULL || *mode == '\0') goto done;
  cmd_len = strlen(cmd);

  if (cmd_len > (sizeof(cmd_buff) - strlen(shell_cmd) - 10))
    goto done; // ERROR

  strcpy(cmd_buff,shell_cmd);
  strcat(cmd_buff, " ");
  if (strncasecmp(shell_base_cmd, "cmd", 3) == 0 || strncasecmp(shell_base_cmd, "command", 7) == 0)
    {
      char tmp[cmd_len + 1];
      strcat(cmd_buff,"/c "); // Run and end
      isCmd = 1;
      strcpy(tmp, cmd);
      for (size_t i=0; i< cmd_len; i++)
	{
	  if (tmp[i] == '/') tmp[i] = '\\';
	  if (tmp[i] == ' ' || tmp[i] == '\t') break;
	}
      strcat(cmd_buff, tmp);
    }
  else
    strcat(cmd_buff, cmd);

  // rb or wb or br or bw or w or r or r+
  if (mode[0] == 'b') mode++; // Not really standard format!
  my_popenmode = (mode[0] == 'r' && (mode[1] == '+' || (mode[1] == 'b' && mode[2] == '+'))) ?  '+' : mode[0];
  if (my_popenmode != 'r' && my_popenmode != 'w' || my_popenmode == '+')
    goto done;

  /*
   * Shall we redirect stderr to stdout ? */
  if (isCmd && (err2out = strstr("2>&1",cmd)) != NULL) {
     /* this option doesn't apply to win32 shells, so we clear it out! */
     strncpy(err2out,"    ",4);
     redirect_error = 1;
  }

  /*
   * Create the Pipes... */
  if (my_pipe(my_pipein)  == -1 ||
      my_pipe(my_pipeout) == -1)
    goto done;
  if (!redirect_error && my_pipe(my_pipeerr) == -1)
    goto done;

  /*
   * Now create the child process */
  ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));
  siStartInfo.cb           = sizeof(STARTUPINFO);
  siStartInfo.hStdInput    = my_pipein[0];
  siStartInfo.hStdOutput   = my_pipeout[1];
  if (redirect_error)
    siStartInfo.hStdError  = my_pipeout[1];
  else
    siStartInfo.hStdError  = my_pipeerr[1];
  siStartInfo.dwFlags    = STARTF_USESTDHANDLES;

  success = CreateProcess(NULL,
     (LPTSTR)cmd_buff,  // command line 
     NULL,              // process security attributes 
     NULL,              // primary thread security attributes 
     TRUE,              // handles are inherited 
     DETACHED_PROCESS,  // creation flags: without window (?)
     NULL,              // use parent's environment 
     NULL,              // use parent's current directory 
     &siStartInfo,      // STARTUPINFO pointer 
     &piProcInfo);      // receives PROCESS_INFORMATION 

  if (!success)
    goto done;

  instances++;
  /*
   * These handles listen to the Child process */
  CloseHandle(my_pipein[0]);  my_pipein[0]  = INVALID_HANDLE_VALUE;
  CloseHandle(my_pipeout[1]); my_pipeout[1] = INVALID_HANDLE_VALUE;
  CloseHandle(my_pipeerr[1]); my_pipeerr[1] = INVALID_HANDLE_VALUE;

  if (my_popenmode == 'r')
    fptr = _fdopen(_open_osfhandle((long)my_pipeout[0],_O_BINARY),"r");
  else if (my_popenmode == 'w')
    fptr = _fdopen(_open_osfhandle((long)my_pipein[1],_O_BINARY),"w");
  else if (my_popenmode == '+')
    fptr = _fdopen(_open_osfhandle((long)my_pipein[1],_O_BINARY),"r+");
  else
    fptr = NULL;

done:
  if (!fptr)
  {
    if (my_pipein[0]  != INVALID_HANDLE_VALUE)
      {
	CloseHandle(my_pipein[0]);
      }
    if (my_pipein[1]  != INVALID_HANDLE_VALUE)
      {
	CloseHandle(my_pipein[1]);
      }
    if (my_pipeout[0] != INVALID_HANDLE_VALUE)
      {
	CloseHandle(my_pipeout[0]);
      }
    if (my_pipeout[1] != INVALID_HANDLE_VALUE)
      {
	CloseHandle(my_pipeout[1]); 
      }
    if (my_pipeerr[0] != INVALID_HANDLE_VALUE)
      {
	CloseHandle(my_pipeerr[0]);
      }
    if (my_pipeerr[1] != INVALID_HANDLE_VALUE)
      {
	CloseHandle(my_pipeerr[1]);
      }
  }
  return fptr;
#endif
}

/*------------------------------------------------------------------------------
  Replacement for 'pclose()' under WIN32
------------------------------------------------------------------------------*/
int _IB_pclose(FILE *fle)
{
#if _ALT_PIPE
  return _my_read_pclose(fle);
#else
  if (fle)
  {
    (void)fclose(fle);

    if ( my_pipeerr[0] != INVALID_HANDLE_VALUE)
      {
	CloseHandle(my_pipeerr[0]);
	my_pipeerr[0]= INVALID_HANDLE_VALUE;
      }
    if (my_popenmode == 'r' || my_popenmode == '+')
      {
	if (my_pipein[1] != INVALID_HANDLE_VALUE)
	  {
	    CloseHandle(my_pipein[1]);
	    my_pipein[1] = INVALID_HANDLE_VALUE;
	  }
      }
    if (my_popenmode == 'w' || my_popenmode == '+')
      {
	if (my_pipeout[0] != INVALID_HANDLE_VALUE)
	  {
	    CloseHandle(my_pipeout[0]);
	    my_pipeout[0] = INVALID_HANDLE_VALUE;
	  }
      }
    if (my_popenmode == 'r' || my_popenmode == 'w' || my_popenmode == '+')
     {
       instances--;
       my_popenmode = ' ';
     }
    return 0;
  }
  return -1;
#endif
}

int _IB_pclose(FILE *fle, int)
{
  return _IB_pclose(fle);
}


extern void _IB_WarningMessage(const char *);

FILE *_IB_popen(const char * const argv[], const char *type)
{
  int  maxlength = 4096;
  char buffer[4096];
  int  length = 0;

  buffer[0] = '\0';
  for (int i=0; argv[i]; i++)
    {
      size_t len = strlen(argv[i]);
      if ((length += 4 + len) >= maxlength)
	{
	  _IB_WarningMessage("Popen args too long");
	  return NULL;
	}
      if (i) strcat(buffer, " \"");
      strcat(buffer, argv[i]);
      if (i) strcat(buffer, "\"");
    }
  return _IB_popen(buffer, type);
}


#else

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>


#ifdef __GNUG__
# undef NO_ALLOCA
#else
# ifndef NO_ALLOCA_H
#  include <alloca.h>
# endif
#endif

#ifdef SOLARIS

extern "C" {
 int sigblock(int mask);
 int sigmask(int signum);
 int sigpause(int mask);
 int sigsetmask(int mask);
} ;

#ifndef sigmask
# define sigmask(n)              ((unsigned int)1 << (((n) - 1) & (32 - 1)))
#endif

#endif

extern void _IB_WarningMessage(const char *);
extern void _IB_PanicMessage(const char *);

#ifndef FORK
# if defined(sun) || defined(__ultrix) || defined(__bsdi__)
#  define FORK vfork
# else
#  define FORK fork
# endif
#endif

#define	MAXGLOBARGS	1024

/*
 * Special version of popen which avoids call to shell.  This ensures noone
 * may create a pipe to a hidden program as a side effect of a list or dir
 * command.
 */
static struct process_table {
  int   pid;
  char *command; 
} *process_table; 

static int fds;

extern FILE *_IB_popen(const char * const argv[], const char *type);

static void process_table_cleanup()
{
  if (process_table == NULL)
    return;

  for (int i=0; i < fds; i++)
    {
      if (process_table[i].command)
	{
	  free(process_table[i].command);
	  process_table[i].command = NULL;
	}
    }
  free (process_table);
  process_table = NULL;
}


static inline char *priv_slash_fixup(char *dest, const char *src)
{
  char *p = dest;
  while ((*dest = *src++) != '\0')
  if (*dest != '\\' || *src == '\\')
    dest++;
  return p;
}

#ifdef NO_ALLOCA
extern char *Copystring(const char *) ;
#endif


FILE *_IB_popen(const char *Command, const char *type)
{
  FILE *fp = NULL;
  char *argv[MAXGLOBARGS];
  int   argc = 0;

  if (Command == NULL) return NULL;

  while (isspace(*Command) || *Command == ';') Command++;

#ifdef NO_ALLOCA
  char       *cmd = Copystring (Command);
#else
  size_t      len = strlen(Command)+1;
# ifdef __GNUG__
  char        cmd[len];
# else
  char       *cmd = (char *)alloca(len);
# endif
  if (cmd) memcpy(cmd, Command, len);
#endif

  char *tcp = (char *)cmd;
  int   quote = 0;
  int   need_fixup = 0;

  if (tcp == NULL)
    return fp;
 
  do { 
    argv[argc++] = tcp;

    if (argc >= (MAXGLOBARGS-1))
      {
	_IB_PanicMessage("_IB_popen: too many arguments. Truncated.");
	break;
      }

    for (;*++tcp;)
      {
	if (quote)
	  {
	    if (*tcp == quote)
	      quote = 0;
	  }
	else if (*tcp == '\\')
	  {
	    need_fixup++;
	    if (*++tcp == '\0')
	      break;
	  }
	else if (*tcp == '"' || *tcp == '\'')
	  quote = *tcp;
	else if (isspace(*tcp))
	  {
	    do {*tcp++ = '\0'; } while (isspace(*tcp));
	    break; // Break out
	  }
      } // for(;;)
  } while (*tcp);

  if (need_fixup)
    {
#ifdef __GNUG__
     char *gargv[argc+1];
#else
# ifdef NO_ALLOCA
      char *gargv[MAXGLOBARGS];
# else
      char **gargv = (char **)alloca((argc+1)*sizeof(char *));
      if (gargv == NULL)
	{
	  _IB_PanicMessage("_IB_popen can't allocate from stack.");
	  return fp; // Can't continue
	}
# endif
#endif

      for (int i=0; i < argc; i++)
	gargv[i] = priv_slash_fixup(new char[strlen(argv[i])+1], argv[i]);
      gargv[argc] = NULL;
  
      fp = _IB_popen(gargv, type);

      for (int j=0; j< argc; j++)
	delete[] gargv[j];
    }
  else
    {
      argv[argc] = NULL;
      fp = _IB_popen(argv, type);
    }

#ifdef NO_ALLOCA
  delete[] cmd;
#endif
  return fp;
}


FILE *_IB_popen(const char * const argv[], const char *type)
{
	char *cp;
	FILE *iop;
	pid_t    pdes[2], pid;
	char **pop;

	if (((*type != 'r') && (*type != 'w')) || type[1])
		return (NULL);

	if (!process_table) {
		if ((fds = getdtablesize()) <= 0)
			return (NULL);
		if ((process_table = (struct process_table *)
			malloc((u_int)(fds * sizeof(struct process_table)))) == NULL)
			return (NULL);
		memset(process_table, 0, fds * sizeof(struct process_table));
		atexit(process_table_cleanup);

	}
	if (pipe(pdes) < 0)
		return (NULL);

	iop = NULL;

	pid = FORK ();

	switch(pid) {
	case -1:			/* error */
		(void)close(pdes[0]);
		(void)close(pdes[1]);
		return iop;
		/* NOTREACHED */
	case 0:				/* child */
		if (*type == 'r') {
			if (pdes[1] != STDOUT_FILENO) {
				dup2(pdes[1], STDOUT_FILENO);
				(void)close(pdes[1]);
			}
			dup2(STDOUT_FILENO, STDERR_FILENO); /* stderr too! */
			(void)close(pdes[0]);
		} else {
			if (pdes[0] != STDIN_FILENO) {
				dup2(pdes[0], STDIN_FILENO);
				(void)close(pdes[0]);
			}
			(void)close(pdes[1]);
		}
#if 0
		{
		   const struct itimerval in, out;
		   if (setitimer(ITIMER_VIRTUAL, &in, &out)) {
		   }
		}
#endif
		execvp(argv[0], (char *const *)argv); // Search PATH too
		_exit(1);
	}

	/* parent; assume fdopen can't fail...  */
	if (*type == 'r') {
		iop = fdopen(pdes[0], type);
		(void)close(pdes[1]);
	} else {
		iop = fdopen(pdes[1], type);
		(void)close(pdes[0]);
	}

	int fdes    = fileno(iop);

	if (fdes >= fds)
	  {
	    _IB_PanicMessage("File handle in _IB_popen exceeds table size!");
	    fclose(iop);
	    kill(pid, SIGKILL);
	    return NULL;
	  }

	process_table[fdes].pid  = pid;
	if ( process_table[fdes].command )
	  free ( process_table[fdes].command );
	process_table[fdes].command = strdup( argv[0] );

	return (iop);
}

int _IB_pclose(FILE *iop, int Zombie)
{
	int fdes, omask, status, runtime;
	pid_t pid;
	const char message[] = "Sub-Process '%s'[PID=%d] %s";
#define Warn(x,s) {char tmp[64]; sprintf(tmp, message, x.command, x.pid, s); _IB_WarningMessage(tmp); }

	/*
	 * pclose returns -1 if stream is not associated with a
	 * `popened' command, or, if already `pclosed'.
	 */
	if (process_table == 0 || process_table[fdes = fileno(iop)].pid == 0)
		return (-1);
	(void)fclose(iop);

	omask = sigblock(sigmask(SIGINT)|sigmask(SIGQUIT)|sigmask(SIGHUP));


	if (Zombie == 0)
	   {
	      while ((pid = waitpid(process_table[fdes].pid, &status, 0)) < 0)
		continue;
	   }
	else
	  {
	    int i;
	    int max_tries = (Zombie > 1 ? Zombie : 20);

	    for (i=0; i < max_tries; i++) {
		while ((pid = waitpid(process_table[fdes].pid, &status, WNOHANG)) < 0)
			continue;
		if (Zombie < 0)
		   break;
		if (pid == 0) {
		  if (i >= 1) {
		    if (i == 1) Warn(process_table[fdes], "wayward? Will try now to kill it..");
		    kill(process_table[fdes].pid, SIGKILL);
		  }
		} else if (pid > 0)
		  break;
		if (i != 1)
		  sleep(1);
	    }
	    if (i >= max_tries && pid > 0) Warn(process_table[fdes], "hung?");
	  }
	(void)sigsetmask(omask);
	process_table[fdes].pid = 0;
	free ( process_table[fdes].command);
	process_table[fdes].command = NULL;
	if (pid < 0)
		return (pid);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (1);
}
#endif
