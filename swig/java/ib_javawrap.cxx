/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.36
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<typename T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTELC__)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1, 
  SWIG_JavaIOException, 
  SWIG_JavaRuntimeException, 
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" } };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13




#pragma ident  "%Z%%Y%%M%  %I% %G% %U% BSN"

//static const long timeout = 979891200; // Expires Fri Jan 19 09:00:00 2001

static const int DebugFlag = 0;

#include "../src/common.hxx"
#include "../src/string.hxx"
#include "../src/vidb.hxx"
#include "../src/rset.hxx"
#include "../src/irset.hxx"
#include "../src/log.hxx"
#include "../src/infix2rpn.hxx"
#include "../src/operator.hxx"

//// Use cached IRSETs..
//#undef IRSET
//#undef PIRSET
//#define IRSET  _IRSET
//#define PIRSET P_IRSET
///

#ifdef SWIGPYTHON
#include "callbacks.hxx"
#endif

#ifdef SHI
 #define JNICALL
 #include "shi.i"
#endif

// #ifdef SWIGPYTHON
// #include "pyglue.cxx"
// #endif

static const ArraySTRING NulArraySTRING;

static const char rFileErrorMsg[] = "file type is required for read parameter";
static const char wFileErrorMsg[] = "file type is required for write parameter";
static const char keyErrorMsg[]   = "key not available";

#ifdef SWIGPYTHON

#define myWrite(f) { \
  FILE *fp = NULL; \
  if (PyString_Check(f)) { \
    if ((fp = fopen( PyString_AsString(f), "a+")) != NULL) \
      f = NULL; \
  } else if (f == NULL || f == Py_None || !PyFile_Check(f)) { \
    PyErr_SetString(PyExc_TypeError, wFileErrorMsg); \
    return NULL; \
  } else fp = PyFile_AsFile(f); \
  bool result = GDT_TRUE; \
  if (fp) self->Write(fp); \
  else result = GDT_FALSE; \
  if (f == NULL) fclose(fp); \
  return Py_BuildValue("i", (int)result); \
}

#define myRead(f) { \
  FILE *fp = NULL; \
  if (PyString_Check(f)) { \
    if ((fp = fopen( PyString_AsString(f), "rb")) != NULL) { \
      f = NULL; \
    } \
  } else if (f == NULL || f == Py_None || !PyFile_Check(f)) { \
    PyErr_SetString(PyExc_TypeError, rFileErrorMsg); \
    return NULL; \
  } else fp = PyFile_AsFile(f); \
  bool result = fp ? self->Read(fp) : GDT_FALSE; \
  if (f == NULL) fclose(fp); \
  return Py_BuildValue("i", (int)result); \
}
#endif

#ifdef SWIGPYTHON

PyObject* PyIB_dict;

#if 0

PyObje* PyIBConstructObject(void* ptr, char* className)
{
    char            buff[64];  // should always be big enough...
    char            swigptr[64];
    _swig_type_info ty;

    ty.name = buff;

    sprintf(buff, "_%s_p", className);
    SWIG_MakePtr(swigptr, ptr, &ty);

    sprintf(buff, "%sPtr", className);
    PyObject* classobj = PyDict_GetItemString(PyIB_dict, buff);
    if (! classobj) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    PyObject* arg = Py_BuildValue("(s)", swigptr);
    PyObject* obj = PyInstance_New(classobj, arg, NULL);
    Py_DECREF(arg);

    return obj;
}
#endif /* SWIGPYTHON */

PyIBCallbackHelper::PyIBCallbackHelper() {
    m_self = NULL;
    m_lastFound = NULL;
}


PyIBCallbackHelper::~PyIBCallbackHelper() {
#ifdef WXP_WITH_THREAD
    PyEval_RestoreThread(PyIBEventThreadState);
#endif

    Py_XDECREF(m_self);

#ifdef WXP_WITH_THREAD
    PyEval_SaveThread();
#endif
}

void PyIBCallbackHelper::setSelf(PyObject* self) {
    m_self = self;
    Py_INCREF(m_self);
}



bool PyIBCallbackHelper::findCallback(const char * name) {
    m_lastFound = NULL;
    if (m_self && PyObject_HasAttrString(m_self, (char *)name))
        m_lastFound = PyObject_GetAttrString(m_self, (char *)name);
    return m_lastFound != NULL;
}


int PyIBCallbackHelper::callCallback(PyObject* argTuple) {
    PyObject*   result;
    int         retval = GDT_FALSE;

    result = callCallbackObj(argTuple);
    if (result) {                       // Assumes an integer return type...
        retval = PyInt_AsLong(result);
        Py_DECREF(result);
        PyErr_Clear();                  // forget about it if it's not...
    }
#ifdef WXP_WITH_THREAD
    PyEval_SaveThread();
#endif
    return retval;
}

// Invoke the Python callable object, returning the raw PyObject return
// value.  Caller should DECREF the return value and also call PyEval_SaveThread.
PyObject* PyIBCallbackHelper::callCallbackObj(PyObject* argTuple) {
#ifdef WXP_WITH_THREAD
    PyEval_RestoreThread(PyIBEventThreadState);
#endif
    PyObject*   result;

    result = PyEval_CallObject(m_lastFound, argTuple);
    Py_DECREF(argTuple);
    if (!result) {
        PyErr_Print();
    }
    return result;
}
#endif

//----------------------------------------------------------------------



SWIGINTERN void SWIG_JavaException(JNIEnv *jenv, int code, const char *msg) {
  SWIG_JavaExceptionCodes exception_code = SWIG_JavaUnknownError;
  switch(code) {
  case SWIG_MemoryError:
    exception_code = SWIG_JavaOutOfMemoryError;
    break;
  case SWIG_IOError:
    exception_code = SWIG_JavaIOException;
    break;
  case SWIG_SystemError:
  case SWIG_RuntimeError:
    exception_code = SWIG_JavaRuntimeException;
    break;
  case SWIG_OverflowError:
  case SWIG_IndexError:
    exception_code = SWIG_JavaIndexOutOfBoundsException;
    break;
  case SWIG_DivisionByZero:
    exception_code = SWIG_JavaArithmeticException;
    break;
  case SWIG_SyntaxError:
  case SWIG_ValueError:
  case SWIG_TypeError:
    exception_code = SWIG_JavaIllegalArgumentException;
    break;
  case SWIG_UnknownError:
  default:
    exception_code = SWIG_JavaUnknownError;
    break;
  }
  SWIG_JavaThrowException(jenv, exception_code, msg);
}


#include <stdexcept>


static char* StringErrorMsg = (char *)"string type is required for parameter";


#ifndef bool
# define bool GDT_BOOLEAN
#endif

SWIGINTERN STRING ArraySTRING___getitem__(ArraySTRING *self,int i){
    return self->GetEntry(i+1);
  }
SWIGINTERN ArraySTRING &ArraySTRING_getself(ArraySTRING *self){ return *self; }
SWIGINTERN STRING ArraySTRING_Join(ArraySTRING *self,char const *seperator){
      STRING result;
      char quotes = '"';
      if (seperator == NULL) seperator = ",";
      else if (strchr(seperator, '"')) quotes = '\'';
      else if (strchr(seperator, '\'')) quotes = '"';
      // Make sure its OK..
      if (strchr(seperator, quotes)) quotes = '\0'; // Nope

      const unsigned  count = self->Count();
      for (unsigned i=0; i< count; i++)
    {
      // Add seperator
      if (i) result.Cat(seperator);
      bool quote = self->Item(i).Search(seperator);
      // Open quote
      if (quote && quotes) result.Cat(quotes);
      // Item
      result.Cat (self->Item(i));
      // Close quote
      if (quote && quotes) result.Cat(quotes);
    }
      return result;
    }
SWIGINTERN void INDEX_ID_SetIndex(INDEX_ID *self,long index){ *self = index; }
SWIGINTERN IRSET &IRSET_getself(IRSET *self){ return *self; }
SWIGINTERN void IRSET_Write(IRSET *self,char const *Path){
      FILE *Fp = fopen(Path, "wb");
      if (Fp)
    self->Write(Fp);
    }
SWIGINTERN void IRSET_Read(IRSET *self,char const *Path){
      FILE *Fp = fopen(Path, "rb");
      if (Fp) self->Read(Fp);
    }
SWIGINTERN bool IRSET_SaveSearch(IRSET *self,STRING const &FileName,QUERY const &Query){
      FILE *fp = FileName.Fopen("wb");
      if (fp)
        {
      STRING("#IB_SEARCH#").Write(fp); // Write Magic
      Query.Write(fp);
          self->Write(fp);
      SRCH_DATE("Now").Write(fp);
          fclose(fp);
      return 1;
        }
      return 0;
    }
SWIGINTERN QUERY *IRSET_LoadSearch(IRSET *self,STRING const &FileName){
      FILE *fp = FileName.Fopen("rb");
      if (fp)
    {
      STRING m;
      m.Read(fp);
      if (m == "#IB_SEARCH#")
        {
          QUERY *QueryPtr = new QUERY();
          QueryPtr->Read(fp);
          self->Read(fp);
          // Could now read a timestamp that we'll ignore
          fclose(fp);
          return QueryPtr;
        }
      fclose(fp);
    }
      return NULL; // No available IRSET
    }
SWIGINTERN RSET &RSET_getself(RSET *self){ return *self; }
SWIGINTERN void RSET_Write(RSET *self,char const *Path){
      FILE *Fp = fopen(Path, "wb");
      if (Fp) self->Write(Fp);
    }
SWIGINTERN void RSET_Read(RSET *self,char const *Path){
      FILE *Fp = fopen(Path, "rb");
      if (Fp) self->Read(Fp);
    }
SWIGINTERN RESULT RSET___getitem__(RSET *self,int i){ return self->GetEntry(i+1); }
SWIGINTERN unsigned int SQUERY_SetWordsAnd__SWIG_0(SQUERY *self,STRING const NewTerm,int Weight=1){
    return self->SetWords(NewTerm, Weight,  OperatorAnd); }
SWIGINTERN STRING SRCH_DATE_Strftime(SRCH_DATE *self,char const *format){
      STRING result;
      if (!self->Strftime(format, &result))
        result.form("*** Error, bad Strftime format: %s", format);
      return result;
    }
SWIGINTERN STRING DATERANGE_ISO(DATERANGE *self){ return (STRING)(*self); }
SWIGINTERN STRING DATERANGE_RFC(DATERANGE *self){
      STRING from, to;
      if (self->RFC(&from, &to))
    return STRING().form("%s To %s", from.c_str(), to.c_str());
      return NulString;
    }
SWIGINTERN STRING DATERANGE_Strftime__SWIG_0(DATERANGE *self,char const *fmt,char const *sep=NULL){
      STRING from, to;
      if (sep == NULL || *sep == '\0') sep = "-";
      if (fmt && self->Strftime(fmt, &from, &to))
        return STRING().form("%s%s%s", from.c_str(), sep, to.c_str());
      return NulString;
    }
SWIGINTERN double DATERANGE_Duration(DATERANGE *self){
    return self->Ok() ? self->GetEnd().GetValue() - self->GetStart().GetValue() : 0.0;
    }
SWIGINTERN int RECORD___len__(RECORD *self){
       return self->GetRecordEnd() - self->GetRecordStart();
    }
SWIGINTERN STRLIST *IDB_GetFieldDefinitionList(IDB const *self){
    STRLIST *list = new STRLIST();
    self->GetFieldDefinitionList(list);
    return list;
  }
SWIGINTERN RECORD *IDB_GetDocumentInfo(IDB *self,int const Index){
     RECORD *pRecord = new RECORD();
     self->GetDocumentInfo(Index, pRecord);
     return pRecord;
  }
SWIGINTERN void IDB_SetDbState(IDB const *self,int DbState){
    enum DbState State = (enum DbState)DbState;
    self->SetDbState(State) ;
  }
SWIGINTERN STRING IDB_GetFieldName__SWIG_0(IDB *self,GPTYPE HitGp){
     STRING Value;
     self->GetPeerFc(HitGp, &Value);
     return Value;
  }
SWIGINTERN STRING IDB_GetFieldName__SWIG_1(IDB *self,FC HitFc){
    STRING Value;
    self->GetPeerFc (HitFc, &Value);
    return Value;
  }
SWIGINTERN bool IDB_AddRecord__SWIG_1(IDB *self,STRING const Filename){
      static DOCTYPE_ID DefaultDoctype ("AUTODETECT");
      RECORD Record (Filename);
      Record.SetDocumentType(DefaultDoctype);
      return self->AddRecord(Record);
    }
SWIGINTERN bool IDB_AppendToIndex(IDB *self,RECORD const Record){
      self->AddRecord(Record);
      return self->Index(0);
    }
SWIGINTERN bool IDB_AppendFileToIndex(IDB *self,STRING const Filename){
      static DOCTYPE_ID DefaultDoctype ("AUTODETECT");
      RECORD Record (Filename);
      Record.SetDocumentType(DefaultDoctype);
      return self->AddRecord(Record) && self->Index(0);
    }
SWIGINTERN STRLIST *IDB_GetFieldData__SWIG_0(IDB *self,RESULT const *ResultPtr,char const *ESet,DOCTYPE_ID Doctype=0){
      if (ResultPtr)
    {
      STRLIST *StrlistPtr = new STRLIST();
      if (Doctype == 0) Doctype =  ResultPtr->GetDocumentType ();
          self->GetFieldData (*ResultPtr, ESet, StrlistPtr, self->GetDocTypePtr ( Doctype ));
      return StrlistPtr;
    }
      return NULL;
    }
SWIGINTERN ArraySTRING IDB_GetFieldContents(IDB *self,RESULT const *ResultPtr,char const *ESet){
      STRLIST Strlist;
      if (ResultPtr)
        self->GetFieldData (*ResultPtr, ESet, &Strlist);
      return ArraySTRING(Strlist);
    }
SWIGINTERN RESULT *IDB_KeyLookup(IDB *self,STRING const Key){
    RESULT *result = new RESULT();
    if (self->KeyLookup(Key, result) == 0) {
      delete result;



      return NULL;
    }
    return result;
   }
SWIGINTERN bool IDB_KeyExists(IDB *self,STRING const Key){ return self->KeyLookup(Key, (RESULT *)NULL); }
SWIGINTERN STRLIST IDB_GetFields__SWIG_0(IDB *self,RESULT const *result=NULL){
    DFDT            Dfdt;
    DFD             Dfd;

    if (result) {
       self->GetRecordDfdt (*result, &Dfdt);
    } else {
      self->GetDfdt(&Dfdt);
    }
    const size_t    total = Dfdt.GetTotalEntries();
    STRLIST list;
    for (int i=0; i < total; i++) {
      Dfdt.GetEntry(i+1, &Dfd);
      list.AddEntry ( Dfd.GetFieldName());
    }
    return list;
  }
SWIGINTERN VIDB &VIDB_getself(VIDB *self){ return *self; }
SWIGINTERN IDB *VIDB_GetIDB__SWIG_0(VIDB *self,unsigned int idx=1){ return (IDB *)self->GetIDB(idx); }
SWIGINTERN ArraySTRING VIDB_GetDocTypeOptions(VIDB const *self){
      return ArraySTRING(self->GetDocTypeOptions());
    }
SWIGINTERN STRLIST *VIDB_GetFieldData__SWIG_0(VIDB *self,RESULT const *ResultPtr,char const *ESet,DOCTYPE_ID Doctype=0){
      if (ResultPtr)
    {
      STRLIST *StrlistPtr = new STRLIST();
      if (Doctype == 0) Doctype =  ResultPtr->GetDocumentType ();
      if (self->GetFieldData (*ResultPtr, ESet, StrlistPtr, self->GetDocTypePtr ( Doctype )) )
        return StrlistPtr;
      delete[] StrlistPtr;
    }
      return NULL; // NULL
    }
SWIGINTERN ArraySTRING VIDB_GetFieldContents(VIDB *self,RESULT const *ResultPtr,char const *ESet){
      STRLIST Strlist;
      if (ResultPtr && self->GetFieldData (*ResultPtr, ESet, &Strlist))
        {
          return ArraySTRING(Strlist);
        }
      return ArraySTRING (0); // Zero list
    }
SWIGINTERN RESULT *VIDB_KeyLookup(VIDB *self,STRING const Key){
      RESULT *result = new RESULT();
      if (self->KeyLookup(Key, result) == 0)
    {
      delete result;



      return NULL;
    }
      return result;
    }
SWIGINTERN bool VIDB_KeyExists(VIDB *self,STRING const Key){ return self->KeyLookup(Key, NULL); }
SWIGINTERN ArraySTRING VIDB_GetFields__SWIG_0(VIDB *self,RESULT const *result=NULL){
    DFDT            Dfdt;
    DFD             Dfd;
    ArraySTRING     list;

    if (result) {
       self->GetRecordDfdt (*result, &Dfdt);
    } else {
      self->GetDfdt(&Dfdt);
    }
    const size_t    total = Dfdt.GetTotalEntries();
    ArraySTRING     List(total);
    for (int i=0; i < total; i++) {
      Dfdt.GetEntry(i+1, &Dfd);
      list.Add ( Dfd.GetFieldName());
    }
    return list;
  }
SWIGINTERN char const *CHARSET_Name(CHARSET const *self){
      return (const char *)self;
    }
SWIGINTERN int CHARSET_UCS(CHARSET *self,char Ch){ return self->UCS((UCHR)Ch); }
SWIGINTERN STRING LOCALE_Name(LOCALE const *self){
      return self->LocaleName();
    }


class __IB {
 public:

  bool FileGlob(const STRING pattern, const STRING str) {
    return ::FileGlob(pattern.c_ustr(), str.c_ustr());
  }
  bool Glob(const STRING pattern, const STRING str, bool dot_special=0) {
    return ::Glob(pattern.c_ustr(), str.c_ustr(), dot_special);
  }

  int FileLink(const STRING Source, const STRING Dest) {
    return ::FileLink(Source, Dest);
  }
  STRING GetUserHome(const STRING user) {
    return ::GetUserHome(user);
  }
  bool DirectoryExists(const STRING Path) {
    return ::DirectoryExists(Path);
  }
  bool FileExists(const STRING Path) {
    return ::FileExists(Path);
  }
  bool ExeExists(const STRING Path) {
    return ExeExists(Path);
  }

  long GetFreeMemory()  { return ::_IB_GetFreeMemory();  }
  long GetTotalMemory() { return ::_IB_GetTotalMemory(); }
  long Hostid()         { return ::_IB_Hostid();         }
  long SerialID()       { return ::_IB_SerialID();       }

  void SendDebugMessage(const char *msg)   { logf(LOG_DEBUG, msg); }
  void SendInfoMessage(const char *msg)    { logf(LOG_INFO, msg);  }
  void SendNoticeMessage(const char *msg)  { logf(LOG_NOTICE, msg);}
  void SendWarningMessage(const char *msg) { logf(LOG_WARN, msg);  }
  void SendErrorMessage(const char *msg)   { logf(LOG_ERROR, msg); }
  void SendErrnoMessage(const char *msg)   { logf(LOG_ERRNO, msg); }
  void SendFatalMessage(const char *msg)   { logf(LOG_FATAL, msg); }
  void SendPanicMessage(const char *msg)   { logf(LOG_PANIC, msg); }

};


#ifdef __cplusplus
extern "C" {
#endif


#ident "%Z%%Y%IB  %I% %G% %U% BSN"

SWIGEXPORT jint JNICALL Java_IBJNI_GDT_1FALSE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) 0;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_GDT_1TRUE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) 1;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_ByExtIndex_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  SortBy result;
  
  (void)jenv;
  (void)jcls;
  result = (SortBy)ByExtIndex;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_OperatorERR_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  t_Operator result;
  
  (void)jenv;
  (void)jcls;
  result = (t_Operator)OperatorERR;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_OperatorNoop_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  t_Operator result;
  
  (void)jenv;
  (void)jcls;
  result = (t_Operator)OperatorNoop;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_OperatorProximity_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  t_Operator result;
  
  (void)jenv;
  (void)jcls;
  result = (t_Operator)OperatorProximity;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_Unnormalized_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  NormalizationMethods result;
  
  (void)jenv;
  (void)jcls;
  result = (NormalizationMethods)Unnormalized;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ELEMENT_1Full_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "F";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ELEMENT_1Brief_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "B";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ELEMENT_1Short_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "S";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ELEMENT_1G_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "G";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ELEMENT_1Raw_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "R";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ELEMENT_1Location_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "L";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ELEMENT_1Metadata_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "M";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORDSYNTAX_1Sutrs_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "1.2.840.10003.5.101";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORDSYNTAX_1Usmarc_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "1.2.840.10003.5.10";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORDSYNTAX_1Html_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "1.2.840.10003.5.108";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORDSYNTAX_1Sgml_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "1.2.840.10003.5.1000.81.1";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORDSYNTAX_1Xml_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "1.2.840.10003.5.1000.81.2";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORDSYNTAX_1Raw_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "1.2.840.10003.5.1000";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORDSYNTAX_1DVBHtml_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "1.2.840.10003.5.1000.34.2";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_copyright_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "Copyright 1999-2000 Edward C. Zimmermann and Basis Systeme netzwerk, Munich Germany.";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_version_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "%I%";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1STRLIST_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (STRLIST *)new STRLIST();
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1STRLIST_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  ArraySTRING arg1 ;
  ArraySTRING const *argp1 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(ArraySTRING **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null ArraySTRING const");
    return 0;
  }
  arg1 = *argp1; 
  result = (STRLIST *)new STRLIST(arg1);
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1STRLIST_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  char **arg1 = (char **) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(char ***)&jarg1; 
  result = (STRLIST *)new STRLIST((char const *const *)arg1);
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Cat_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRLIST *arg2 = 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = *(STRLIST **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "STRLIST const & reference is null");
    return 0;
  } 
  {
    STRLIST &_result_ref = (arg1)->Cat((STRLIST const &)*arg2);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Cat_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  ArraySTRING arg2 ;
  ArraySTRING const *argp2 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(STRLIST **)&jarg1; 
  argp2 = *(ArraySTRING **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null ArraySTRING const");
    return 0;
  }
  arg2 = *argp2; 
  {
    STRLIST &_result_ref = (arg1)->Cat(arg2);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Cat_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char **arg2 = (char **) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = *(char ***)&jarg2; 
  {
    STRLIST &_result_ref = (arg1)->Cat((char const *const *)arg2);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1AddEntry_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char *arg2 = (char *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (STRLIST *)(arg1)->AddEntry((char const *)arg2);
  *(STRLIST **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1AddEntry_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRLIST *arg2 = 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = *(STRLIST **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "STRLIST const & reference is null");
    return 0;
  } 
  result = (STRLIST *)(arg1)->AddEntry((STRLIST const &)*arg2);
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1SetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  unsigned int arg2 ;
  char *arg3 = (char *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (STRLIST *)(arg1)->SetEntry(arg2,(char const *)arg3);
  *(STRLIST **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_STRLIST_1GetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jstring jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  unsigned int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (arg1)->GetEntry(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_STRLIST_1DeleteEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jboolean jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  unsigned int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)(arg1)->DeleteEntry(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Next(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  result = (STRLIST *)(arg1)->Next();
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Prev(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  result = (STRLIST *)(arg1)->Prev();
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_STRLIST_1Value(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  result = (arg1)->Value();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1GetTotalEntries(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  result = (unsigned int)((STRLIST const *)arg1)->GetTotalEntries();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Sort(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  result = (unsigned int)(arg1)->Sort();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1UniqueSort(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  result = (unsigned int)(arg1)->UniqueSort();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1SplitWords_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char *arg2 = (char *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  {
    STRLIST &_result_ref = (arg1)->SplitWords((char const *)arg2);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1SplitTerms_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char *arg2 = (char *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  {
    STRLIST &_result_ref = (arg1)->SplitTerms((char const *)arg2);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1SplitPaths_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char *arg2 = (char *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  {
    STRLIST &_result_ref = (arg1)->SplitPaths((char const *)arg2);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Split_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char arg2 ;
  STRING arg3 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = (char)jarg2; 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  {
    STRLIST &_result_ref = (arg1)->Split(arg2,arg3);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Split_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char *arg2 = (char *) 0 ;
  STRING arg3 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  {
    STRLIST &_result_ref = (arg1)->Split((char const *)arg2,arg3);
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_STRLIST_1Join_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jstring jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = (char)jarg2; 
  result = ((STRLIST const *)arg1)->Join(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_STRLIST_1Join_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  char *arg2 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = ((STRLIST const *)arg1)->Join((char const *)arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1Search(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)((STRLIST const *)arg1)->Search(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_STRLIST_1SearchCase(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)((STRLIST const *)arg1)->SearchCase(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_STRLIST_1GetValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  STRLIST *arg1 = (STRLIST *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((STRLIST const *)arg1)->GetValue(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1STRLIST(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  STRLIST *arg1 = (STRLIST *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(STRLIST **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1ArraySTRING_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  ArraySTRING *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (ArraySTRING *)new ArraySTRING();
  *(ArraySTRING **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1ArraySTRING_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int arg1 ;
  ArraySTRING *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (ArraySTRING *)new ArraySTRING(arg1);
  *(ArraySTRING **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1ArraySTRING_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  ArraySTRING arg1 ;
  ArraySTRING const *argp1 ;
  ArraySTRING *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(ArraySTRING **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null ArraySTRING const");
    return 0;
  }
  arg1 = *argp1; 
  result = (ArraySTRING *)new ArraySTRING(arg1);
  *(ArraySTRING **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1ArraySTRING_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  STRLIST *arg1 = 0 ;
  ArraySTRING *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(STRLIST **)&jarg1;
  if(!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "STRLIST const & reference is null");
    return 0;
  } 
  result = (ArraySTRING *)new ArraySTRING((STRLIST const &)*arg1);
  *(ArraySTRING **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1ArraySTRING(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(ArraySTRING **)&jarg1; 
  delete arg1;
}


SWIGEXPORT void JNICALL Java_IBJNI_ArraySTRING_1Empty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  (arg1)->Empty();
}


SWIGEXPORT void JNICALL Java_IBJNI_ArraySTRING_1Clear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  (arg1)->Clear();
}


SWIGEXPORT jlong JNICALL Java_IBJNI_ArraySTRING_1Count(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  result = (unsigned int)((ArraySTRING const *)arg1)->Count();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_ArraySTRING_1IsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  result = (bool)(arg1)->IsEmpty();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ArraySTRING_1Item(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jstring jresult = 0 ;
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  unsigned int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = ((ArraySTRING const *)arg1)->Item(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ArraySTRING_1GetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jstring jresult = 0 ;
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  unsigned int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = ((ArraySTRING const *)arg1)->GetEntry(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ArraySTRING_1_1_1getitem_1_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = (int)jarg2; 
  result = ArraySTRING___getitem__(arg1,arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_ArraySTRING_1SetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jstring jarg3) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  unsigned int arg2 ;
  char *arg3 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return ;
  }
  (arg1)->SetEntry(arg2,(char const *)arg3);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_ArraySTRING_1Add(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->Add((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_ArraySTRING_1Insert(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  char *arg2 = (char *) 0 ;
  unsigned int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  arg3 = (unsigned int)jarg3; 
  (arg1)->Insert((char const *)arg2,arg3);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_ArraySTRING_1Replace(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  char *arg2 = (char *) 0 ;
  unsigned int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  arg3 = (unsigned int)jarg3; 
  (arg1)->Replace((char const *)arg2,arg3);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_ArraySTRING_1Remove(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->Remove(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_ArraySTRING_1getself(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  ArraySTRING *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  {
    ArraySTRING &_result_ref = ArraySTRING_getself(arg1);
    result = (ArraySTRING *) &_result_ref;
  }
  *(ArraySTRING **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ArraySTRING_1Join(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  ArraySTRING *arg1 = (ArraySTRING *) 0 ;
  char *arg2 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(ArraySTRING **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = ArraySTRING_Join(arg1,(char const *)arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1IDB_1STATS(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  IDB_STATS *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (IDB_STATS *)new IDB_STATS();
  *(IDB_STATS **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1IDB_1STATS(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(IDB_STATS **)&jarg1; 
  delete arg1;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1STATS_1SetHits(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  size_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB_STATS **)&jarg1; 
  arg2 = (size_t)jarg2; 
  (arg1)->SetHits(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1STATS_1SetTotal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  size_t arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB_STATS **)&jarg1; 
  arg2 = (size_t)jarg2; 
  (arg1)->SetTotal(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1STATS_1GetTotal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB_STATS **)&jarg1; 
  result = ((IDB_STATS const *)arg1)->GetTotal();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1STATS_1GetHits(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB_STATS **)&jarg1; 
  result = ((IDB_STATS const *)arg1)->GetHits();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1STATS_1Clear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB_STATS **)&jarg1; 
  (arg1)->Clear();
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1STATS_1SetName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB_STATS **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetName(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1STATS_1GetName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB_STATS *arg1 = (IDB_STATS *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB_STATS **)&jarg1; 
  result = ((IDB_STATS const *)arg1)->GetName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1VIDB_1STATS(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  VIDB_STATS *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (VIDB_STATS *)new VIDB_STATS();
  *(VIDB_STATS **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1VIDB_1STATS(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  VIDB_STATS *arg1 = (VIDB_STATS *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(VIDB_STATS **)&jarg1; 
  delete arg1;
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1STATS_1Clear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  VIDB_STATS *arg1 = (VIDB_STATS *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB_STATS **)&jarg1; 
  (arg1)->Clear();
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1STATS_1SetTotal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
  VIDB_STATS *arg1 = (VIDB_STATS *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB_STATS **)&jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  (arg1)->SetTotal(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1STATS_1SetHits(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
  VIDB_STATS *arg1 = (VIDB_STATS *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB_STATS **)&jarg1; 
  arg2 = (size_t)jarg2; 
  arg3 = (size_t)jarg3; 
  (arg1)->SetHits(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1STATS_1SetName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jstring jarg3) {
  VIDB_STATS *arg1 = (VIDB_STATS *) 0 ;
  size_t arg2 ;
  STRING arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB_STATS **)&jarg1; 
  arg2 = (size_t)jarg2; 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return ;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  (arg1)->SetName(arg2,arg3);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1IDBOBJ(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  IDBOBJ *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (IDBOBJ *)new IDBOBJ();
  *(IDBOBJ **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1IDBOBJ(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(IDBOBJ **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDBOBJ_1getUseRelativePaths(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  result = (bool)((IDBOBJ const *)arg1)->getUseRelativePaths();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDBOBJ_1setUseRelativePaths_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  jboolean jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  bool arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  result = (bool)(arg1)->setUseRelativePaths(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDBOBJ_1setUseRelativePaths_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  result = (bool)(arg1)->setUseRelativePaths();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDBOBJ_1RelativizePathname(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((IDBOBJ const *)arg1)->RelativizePathname(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDBOBJ_1ResolvePathname(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((IDBOBJ const *)arg1)->ResolvePathname(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1INDEX_1ID_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  INDEX_ID *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (INDEX_ID *)new INDEX_ID();
  *(INDEX_ID **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1INDEX_1ID_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  INDEX_ID arg1 ;
  INDEX_ID const *argp1 ;
  INDEX_ID *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(INDEX_ID **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null INDEX_ID const");
    return 0;
  }
  arg1 = *argp1; 
  result = (INDEX_ID *)new INDEX_ID(arg1);
  *(INDEX_ID **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1INDEX_1ID(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(INDEX_ID **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jint JNICALL Java_IBJNI_INDEX_1ID_1GetIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INDEX_ID **)&jarg1; 
  result = (long)(arg1)->GetIndex();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_INDEX_1ID_1SetIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  long arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INDEX_ID **)&jarg1; 
  arg2 = (long)jarg2; 
  INDEX_ID_SetIndex(arg1,arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_INDEX_1ID_1SetMdtIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INDEX_ID **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetMdtIndex(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_INDEX_1ID_1GetMdtIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INDEX_ID **)&jarg1; 
  result = (unsigned int)((INDEX_ID const *)arg1)->GetMdtIndex();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_INDEX_1ID_1SetVirtualIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INDEX_ID **)&jarg1; 
  arg2 = (int)jarg2; 
  (arg1)->SetVirtualIndex(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_INDEX_1ID_1GetVirtualIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INDEX_ID **)&jarg1; 
  result = (int)((INDEX_ID const *)arg1)->GetVirtualIndex();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_INDEX_1ID_1Equals(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  INDEX_ID arg2 ;
  INDEX_ID *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(INDEX_ID **)&jarg1; 
  argp2 = *(INDEX_ID **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null INDEX_ID");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)((INDEX_ID const *)arg1)->Equals(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_INDEX_1ID_1Compare(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  INDEX_ID *arg1 = (INDEX_ID *) 0 ;
  INDEX_ID arg2 ;
  INDEX_ID *argp2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(INDEX_ID **)&jarg1; 
  argp2 = *(INDEX_ID **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null INDEX_ID");
    return 0;
  }
  arg2 = *argp2; 
  result = (int)((INDEX_ID const *)arg1)->Compare(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DOCTYPE_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  DOCTYPE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (DOCTYPE *)new DOCTYPE();
  *(DOCTYPE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DOCTYPE_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  char *arg2 = (char *) 0 ;
  DOCTYPE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (DOCTYPE *)new DOCTYPE(arg1,(char const *)arg2);
  *(DOCTYPE **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DOCTYPE_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  DOCTYPE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  result = (DOCTYPE *)new DOCTYPE(arg1);
  *(DOCTYPE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DOCTYPE_1ParseDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  DOCTYPE *arg1 = (DOCTYPE *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOCTYPE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = ((DOCTYPE const *)arg1)->ParseDate((char const *)arg2,(char const *)arg3);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DOCTYPE_1ParseDateRange(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  DOCTYPE *arg1 = (DOCTYPE *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< DATERANGE > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOCTYPE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = ((DOCTYPE const *)arg1)->ParseDateRange((char const *)arg2,(char const *)arg3);
  *(DATERANGE **)&jresult = new DATERANGE((const DATERANGE &)result); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1DOCTYPE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  DOCTYPE *arg1 = (DOCTYPE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(DOCTYPE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DTREG_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  DTREG *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  result = (DTREG *)new DTREG(arg1);
  *(DTREG **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DTREG_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  STRING arg2 ;
  DTREG *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (DTREG *)new DTREG(arg1,arg2);
  *(DTREG **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DTREG_1PluginExists(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DTREG **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)((DTREG const *)arg1)->PluginExists(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_DTREG_1AddPluginPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  DTREG *arg1 = (DTREG *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DTREG **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->AddPluginPath(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DTREG_1GetDocTypePtr_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  STRING arg2 ;
  DOCTYPE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DTREG **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (DOCTYPE *)(arg1)->GetDocTypePtr(arg2);
  *(DOCTYPE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DTREG_1GetDocTypePtr_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  DOCTYPE_ID *arg2 = 0 ;
  DOCTYPE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DTREG **)&jarg1; 
  arg2 = *(DOCTYPE_ID **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "DOCTYPE_ID const & reference is null");
    return 0;
  } 
  result = (DOCTYPE *)(arg1)->GetDocTypePtr((DOCTYPE_ID const &)*arg2);
  *(DOCTYPE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DTREG_1GetDocTypePtr_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  DOCTYPE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DTREG **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (DOCTYPE *)(arg1)->GetDocTypePtr((char const *)arg2,(char const *)arg3);
  *(DOCTYPE **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DTREG_1ValidateDocType_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DTREG **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->ValidateDocType(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DTREG_1ValidateDocType_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  DOCTYPE_ID *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DTREG **)&jarg1; 
  arg2 = *(DOCTYPE_ID **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "DOCTYPE_ID const & reference is null");
    return 0;
  } 
  result = (bool)(arg1)->ValidateDocType((DOCTYPE_ID const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DTREG_1GetDocTypeList(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DTREG **)&jarg1; 
  {
    STRLIST const &_result_ref = (arg1)->GetDocTypeList();
    result = (STRLIST *) &_result_ref;
  }
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_DTREG_1Version(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  DTREG *arg1 = (DTREG *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DTREG **)&jarg1; 
  result = (int)((DTREG const *)arg1)->Version();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1DTREG(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  DTREG *arg1 = (DTREG *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(DTREG **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1MDTREC_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  MDTREC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  result = (MDTREC *)new MDTREC(arg1);
  *(MDTREC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1MDTREC_1_1SWIG_11(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  MDTREC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (MDTREC *)new MDTREC();
  *(MDTREC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetCategory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetCategory(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDTREC_1GetCategory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = (unsigned int)((MDTREC const *)arg1)->GetCategory();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetPriority(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jshort jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  short arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  arg2 = (short)jarg2; 
  (arg1)->SetPriority(arg2);
}


SWIGEXPORT jshort JNICALL Java_IBJNI_MDTREC_1GetPriority(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jshort jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  short result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = (short)((MDTREC const *)arg1)->GetPriority();
  jresult = (jshort)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SetKey((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_MDTREC_1GetKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetDocumentType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > arg2 ;
  DOCTYPE_ID const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(MDTREC **)&jarg1; 
  argp2 = *(DOCTYPE_ID **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DOCTYPE_ID const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDocumentType(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDTREC_1GetDocumentType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetDocumentType();
  *(DOCTYPE_ID **)&jresult = new DOCTYPE_ID((const DOCTYPE_ID &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetPath(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_MDTREC_1GetPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetPath();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetFileName(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_MDTREC_1GetFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetFileName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetFullFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetFullFileName(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_MDTREC_1GetFullFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetFullFileName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetGlobalFileStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  GPTYPE arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return ;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  (arg1)->SetGlobalFileStart(arg2);
}


SWIGEXPORT jobject JNICALL Java_IBJNI_MDTREC_1GetGlobalFileStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jobject jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  GPTYPE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = (GPTYPE)((MDTREC const *)arg1)->GetGlobalFileStart();
  {
    jbyteArray ba = jenv->NewByteArray(9);
    jbyte* bae = jenv->GetByteArrayElements(ba, 0);
    jclass clazz = jenv->FindClass("java/math/BigInteger");
    jmethodID mid = jenv->GetMethodID(clazz, "<init>", "([B)V");
    jobject bigint;
    int i;
    
    bae[0] = 0;
    for(i=1; i<9; i++ ) {
      bae[i] = (jbyte)(result>>8*(8-i));
    }
    
    jenv->ReleaseByteArrayElements(ba, bae, 0);
    bigint = jenv->NewObject(clazz, mid, ba);
    jresult = bigint;
  }
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetLocalRecordStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  GPTYPE arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return ;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  (arg1)->SetLocalRecordStart(arg2);
}


SWIGEXPORT jobject JNICALL Java_IBJNI_MDTREC_1GetLocalRecordStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jobject jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  GPTYPE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = (GPTYPE)((MDTREC const *)arg1)->GetLocalRecordStart();
  {
    jbyteArray ba = jenv->NewByteArray(9);
    jbyte* bae = jenv->GetByteArrayElements(ba, 0);
    jclass clazz = jenv->FindClass("java/math/BigInteger");
    jmethodID mid = jenv->GetMethodID(clazz, "<init>", "([B)V");
    jobject bigint;
    int i;
    
    bae[0] = 0;
    for(i=1; i<9; i++ ) {
      bae[i] = (jbyte)(result>>8*(8-i));
    }
    
    jenv->ReleaseByteArrayElements(ba, bae, 0);
    bigint = jenv->NewObject(clazz, mid, ba);
    jresult = bigint;
  }
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetLocalRecordEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  GPTYPE arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return ;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  (arg1)->SetLocalRecordEnd(arg2);
}


SWIGEXPORT jobject JNICALL Java_IBJNI_MDTREC_1GetLocalRecordEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jobject jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  GPTYPE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = (GPTYPE)((MDTREC const *)arg1)->GetLocalRecordEnd();
  {
    jbyteArray ba = jenv->NewByteArray(9);
    jbyte* bae = jenv->GetByteArrayElements(ba, 0);
    jclass clazz = jenv->FindClass("java/math/BigInteger");
    jmethodID mid = jenv->GetMethodID(clazz, "<init>", "([B)V");
    jobject bigint;
    int i;
    
    bae[0] = 0;
    for(i=1; i<9; i++ ) {
      bae[i] = (jbyte)(result>>8*(8-i));
    }
    
    jenv->ReleaseByteArrayElements(ba, bae, 0);
    bigint = jenv->NewObject(clazz, mid, ba);
    jresult = bigint;
  }
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetLocale(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  LOCALE arg2 ;
  LOCALE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(MDTREC **)&jarg1; 
  argp2 = *(LOCALE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null LOCALE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetLocale(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDTREC_1GetLocale(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  LOCALE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetLocale();
  *(LOCALE **)&jresult = new LOCALE((const LOCALE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(MDTREC **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDate(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDTREC_1GetDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetDate();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetDateModified(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(MDTREC **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDateModified(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDTREC_1GetDateModified(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetDateModified();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetDateCreated(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(MDTREC **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDateCreated(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDTREC_1GetDateCreated(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetDateCreated();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetDateExpires(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(MDTREC **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDateExpires(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDTREC_1GetDateExpires(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->GetDateExpires();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_MDTREC_1TTL_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = (int)((MDTREC const *)arg1)->TTL();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_MDTREC_1TTL_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(MDTREC **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return 0;
  }
  arg2 = *argp2; 
  result = (int)((MDTREC const *)arg1)->TTL(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1SetDeleted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetDeleted(arg2);
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_MDTREC_1GetDeleted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = (bool)((MDTREC const *)arg1)->GetDeleted();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDTREC_1FlipBytes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  (arg1)->FlipBytes();
}


SWIGEXPORT jstring JNICALL Java_IBJNI_MDTREC_1Dump(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  MDTREC *arg1 = (MDTREC *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1; 
  result = ((MDTREC const *)arg1)->Dump();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1MDTREC(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  MDTREC *arg1 = (MDTREC *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(MDTREC **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1MDT(JNIEnv *jenv, jclass jcls, jstring jarg1, jboolean jarg2) {
  jlong jresult = 0 ;
  STRING arg1 ;
  bool arg2 ;
  MDT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  arg2 = jarg2 ? true : false; 
  result = (MDT *)new MDT(arg1,arg2);
  *(MDT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_MDT_1GetFileStem(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  result = ((MDT const *)arg1)->GetFileStem();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_MDT_1SetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_) {
  MDT *arg1 = (MDT *) 0 ;
  unsigned int arg2 ;
  MDTREC arg3 ;
  MDTREC const *argp3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(MDT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  argp3 = *(MDTREC **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null MDTREC const");
    return ;
  }
  arg3 = *argp3; 
  (arg1)->SetEntry(arg2,arg3);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDT_1LookupByKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  char *arg2 = (char *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (unsigned int)(arg1)->LookupByKey((char const *)arg2);
  jresult = (jlong)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDT_1GetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  unsigned int arg2 ;
  MDTREC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (MDTREC *)(arg1)->GetEntry(arg2);
  *(MDTREC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_MDT_1Delete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jboolean jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  unsigned int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)(arg1)->Delete(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_MDT_1UnDelete(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jboolean jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  unsigned int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)(arg1)->UnDelete(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_MDT_1IsDeleted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jboolean jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  unsigned int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (bool)(arg1)->IsDeleted(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDT_1GetTotalEntries(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalEntries();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDT_1GetTotalDeleted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalDeleted();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_MDT_1GetChanged(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  result = (bool)((MDT const *)arg1)->GetChanged();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_MDT_1RemoveDeleted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  result = (unsigned int)(arg1)->RemoveDeleted();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_MDT_1Ok(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  MDT *arg1 = (MDT *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDT **)&jarg1; 
  result = (bool)((MDT const *)arg1)->Ok();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1MDT(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  MDT *arg1 = (MDT *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(MDT **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FC_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  FC arg1 ;
  FC *argp1 ;
  FC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(FC **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg1 = *argp1; 
  result = (FC *)new FC(arg1);
  *(FC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FC_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  GPTYPE *arg1 = (GPTYPE *) 0 ;
  FC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(GPTYPE **)&jarg1; 
  result = (FC *)new FC(arg1);
  *(FC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FC_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2) {
  jlong jresult = 0 ;
  GPTYPE arg1 ;
  GPTYPE arg2 ;
  FC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg1) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg1);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg1, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg1 = 0;
    for(i=0; i<sz; i++) {
      arg1 = (arg1 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE const)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  result = (FC *)new FC(arg1,arg2);
  *(FC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FC_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
  jlong jresult = 0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  FC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (FC *)new FC(arg1,arg2);
  *(FC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FC_1_1SWIG_14(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  unsigned int arg1 ;
  FC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (unsigned int)jarg1; 
  result = (FC *)new FC(arg1);
  *(FC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FC_1_1SWIG_15(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  FC *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (FC *)new FC();
  *(FC **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_FC_1SetFieldStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  FC *arg1 = (FC *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FC **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetFieldStart(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_FC_1SetFieldEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  FC *arg1 = (FC *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FC **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetFieldEnd(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_FC_1GetFieldStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  FC *arg1 = (FC *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FC **)&jarg1; 
  result = (unsigned int)(arg1)->GetFieldStart();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_FC_1GetFieldEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  FC *arg1 = (FC *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FC **)&jarg1; 
  result = (unsigned int)(arg1)->GetFieldEnd();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_FC_1GetLength(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  FC *arg1 = (FC *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FC **)&jarg1; 
  result = (unsigned int)(arg1)->GetLength();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_FC_1Compare(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  FC *arg1 = (FC *) 0 ;
  FC arg2 ;
  FC const *argp2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(FC **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC const");
    return 0;
  }
  arg2 = *argp2; 
  result = (int)(arg1)->Compare(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_FC_1Contains(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  FC *arg1 = (FC *) 0 ;
  FC arg2 ;
  FC const *argp2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(FC **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC const");
    return 0;
  }
  arg2 = *argp2; 
  result = (int)(arg1)->Contains(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_FC_1FlipBytes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  FC *arg1 = (FC *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FC **)&jarg1; 
  (arg1)->FlipBytes();
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1FC(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  FC *arg1 = (FC *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(FC **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FCT(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  FCT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (FCT *)new FCT();
  *(FCT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_FCT_1AddEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  FCT *arg1 = (FCT *) 0 ;
  FC arg2 ;
  FC const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(FCT **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->AddEntry(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_FCT_1GetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  FCT *arg1 = (FCT *) 0 ;
  unsigned int arg2 ;
  FC result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (arg1)->GetEntry(arg2);
  *(FC **)&jresult = new FC((const FC &)result); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCT_1IsSorted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  FCT *arg1 = (FCT *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCT **)&jarg1; 
  result = (bool)(arg1)->IsSorted();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCT_1IsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  FCT *arg1 = (FCT *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCT **)&jarg1; 
  result = (bool)(arg1)->IsEmpty();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_FCT_1GetTotalEntries(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  FCT *arg1 = (FCT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCT **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalEntries();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_FCT_1Reverse(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  FCT *arg1 = (FCT *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCT **)&jarg1; 
  (arg1)->Reverse();
}


SWIGEXPORT void JNICALL Java_IBJNI_FCT_1SortByFc(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  FCT *arg1 = (FCT *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCT **)&jarg1; 
  (arg1)->SortByFc();
}


SWIGEXPORT jint JNICALL Java_IBJNI_FCT_1Refcount_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  FCT *arg1 = (FCT *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCT **)&jarg1; 
  result = (int)(arg1)->Refcount_();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1FCT(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  FCT *arg1 = (FCT *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(FCT **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1TREENODE_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  TREENODE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (TREENODE *)new TREENODE();
  *(TREENODE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1TREENODE_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  FC arg1 ;
  char *arg2 = (char *) 0 ;
  FC const *argp1 ;
  TREENODE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(FC **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC const");
    return 0;
  }
  arg1 = *argp1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (TREENODE *)new TREENODE(arg1,(char const *)arg2);
  *(TREENODE **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1TREENODE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  TREENODE *arg1 = (TREENODE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(TREENODE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_TREENODE_1Name(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  TREENODE *arg1 = (TREENODE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TREENODE **)&jarg1; 
  result = (arg1)->Name();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_TREENODE_1Fc(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  TREENODE *arg1 = (TREENODE *) 0 ;
  FC result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(TREENODE **)&jarg1; 
  result = (arg1)->Fc();
  *(FC **)&jresult = new FC((const FC &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1NODETREE_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  NODETREE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (NODETREE *)new NODETREE();
  *(NODETREE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1NODETREE_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NODETREE arg1 ;
  NODETREE const *argp1 ;
  NODETREE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(NODETREE **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null NODETREE const");
    return 0;
  }
  arg1 = *argp1; 
  result = (NODETREE *)new NODETREE(arg1);
  *(NODETREE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_NODETREE_1AddEntry_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  NODETREE *arg1 = (NODETREE *) 0 ;
  TREENODE arg2 ;
  TREENODE const *argp2 ;
  TREENODELIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(NODETREE **)&jarg1; 
  argp2 = *(TREENODE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null TREENODE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (TREENODELIST *)(arg1)->AddEntry(arg2);
  *(TREENODELIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_NODETREE_1AddEntry_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  NODETREE *arg1 = (NODETREE *) 0 ;
  NODETREE arg2 ;
  NODETREE const *argp2 ;
  TREENODELIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(NODETREE **)&jarg1; 
  argp2 = *(NODETREE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null NODETREE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (TREENODELIST *)(arg1)->AddEntry(arg2);
  *(TREENODELIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_NODETREE_1Clear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  NODETREE *arg1 = (NODETREE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  (arg1)->Clear();
}


SWIGEXPORT void JNICALL Java_IBJNI_NODETREE_1Reverse(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  NODETREE *arg1 = (NODETREE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  (arg1)->Reverse();
}


SWIGEXPORT void JNICALL Java_IBJNI_NODETREE_1Sort(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  NODETREE *arg1 = (NODETREE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  (arg1)->Sort();
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_NODETREE_1IsSorted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  NODETREE *arg1 = (NODETREE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  result = (bool)(arg1)->IsSorted();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_NODETREE_1IsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  NODETREE *arg1 = (NODETREE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  result = (bool)(arg1)->IsEmpty();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_NODETREE_1GetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  NODETREE *arg1 = (NODETREE *) 0 ;
  int arg2 ;
  TREENODE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->GetEntry(arg2);
  *(TREENODE **)&jresult = new TREENODE((const TREENODE &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_NODETREE_1XMLNodeTree_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  NODETREE *arg1 = (NODETREE *) 0 ;
  char *arg2 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (arg1)->XMLNodeTree((char const *)arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_NODETREE_1XMLNodeTree_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  NODETREE *arg1 = (NODETREE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NODETREE **)&jarg1; 
  result = (arg1)->XMLNodeTree();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1NODETREE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  NODETREE *arg1 = (NODETREE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(NODETREE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RESULT_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  RESULT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (RESULT *)new RESULT();
  *(RESULT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RESULT_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  MDTREC *arg1 = 0 ;
  RESULT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(MDTREC **)&jarg1;
  if(!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "MDTREC const & reference is null");
    return 0;
  } 
  result = (RESULT *)new RESULT((MDTREC const &)*arg1);
  *(RESULT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RESULT_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = 0 ;
  RESULT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1;
  if(!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RESULT const & reference is null");
    return 0;
  } 
  result = (RESULT *)new RESULT((RESULT const &)*arg1);
  *(RESULT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RESULT_1SetIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  RESULT *arg1 = (RESULT *) 0 ;
  INDEX_ID arg2 ;
  INDEX_ID const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RESULT **)&jarg1; 
  argp2 = *(INDEX_ID **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null INDEX_ID const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetIndex(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  INDEX_ID result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetIndex();
  *(INDEX_ID **)&jresult = new INDEX_ID((const INDEX_ID &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RESULT_1SetMdtIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  RESULT *arg1 = (RESULT *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetMdtIndex(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetMdtIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (unsigned int)((RESULT const *)arg1)->GetMdtIndex();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RESULT_1SetVirtualIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  RESULT *arg1 = (RESULT *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetVirtualIndex(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetVirtualIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (unsigned int)((RESULT const *)arg1)->GetVirtualIndex();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RESULT_1GetCategory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (long)((RESULT const *)arg1)->GetCategory();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RESULT_1SetCategory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  RESULT *arg1 = (RESULT *) 0 ;
  long arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  arg2 = (long)jarg2; 
  (arg1)->SetCategory(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_RESULT_1SetKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RESULT *arg1 = (RESULT *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SetKey((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetGlobalKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetGlobalKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetLanguageCode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (char *)((RESULT const *)arg1)->GetLanguageCode();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetCharsetCode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (char *)((RESULT const *)arg1)->GetCharsetCode();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetLanguageName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (char *)((RESULT const *)arg1)->GetLanguageName();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetCharsetName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (char *)((RESULT const *)arg1)->GetCharsetName();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetFullFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetFullFileName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetPath();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetFileName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1GetDoctype(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetDoctype();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RESULT_1GetRecordStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (long)((RESULT const *)arg1)->GetRecordStart();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RESULT_1GetRecordEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (long)((RESULT const *)arg1)->GetRecordEnd();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RESULT_1GetLength(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (long)((RESULT const *)arg1)->GetLength();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RESULT_1GetRecordSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (long)((RESULT const *)arg1)->GetRecordSize();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_RESULT_1GetScore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (double)((RESULT const *)arg1)->GetScore();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetAuxCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (unsigned int)((RESULT const *)arg1)->GetAuxCount();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetHitTotal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (unsigned int)((RESULT const *)arg1)->GetHitTotal();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetDate();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetDateModified(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetDateModified();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetDateCreated(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetDateCreated();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RESULT_1GetHitTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  FCT result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->GetHitTable();
  *(FCT **)&jresult = new FCT((const FCT &)result); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RESULT_1GetRefcount_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = (int)((RESULT const *)arg1)->GetRefcount_();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RESULT_1XMLHitTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RESULT *arg1 = (RESULT *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RESULT **)&jarg1; 
  result = ((RESULT const *)arg1)->XMLHitTable();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1RESULT(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  RESULT *arg1 = (RESULT *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(RESULT **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1IRSET_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  unsigned int arg2 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (IRSET *)new IRSET(arg1,arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1IRSET_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  result = (IRSET *)new IRSET(arg1);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1getself(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  {
    IRSET &_result_ref = IRSET_getself(arg1);
    result = (IRSET *) &_result_ref;
  }
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IRSET_1Write(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IRSET *arg1 = (IRSET *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  IRSET_Write(arg1,(char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IRSET_1Read(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IRSET *arg1 = (IRSET *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  IRSET_Read(arg1,(char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IRSET_1LoadTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IRSET *arg1 = (IRSET *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->LoadTable(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IRSET_1SaveTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IRSET *arg1 = (IRSET *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  ((IRSET const *)arg1)->SaveTable(arg2);
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IRSET_1SaveSearch(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_) {
  jboolean jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  STRING *arg2 = 0 ;
  QUERY *arg3 = 0 ;
  STRING temp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(IRSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      temp2 = rtn;
      arg2 = &temp2;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      temp2 = rtn;
      arg2 = &temp2;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    temp2 = arg2_pstr;
    arg2 = &temp2;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
  }
#endif
  
  arg3 = *(QUERY **)&jarg3;
  if(!arg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  result = (bool)IRSET_SaveSearch(arg1,(STRING const &)*arg2,(QUERY const &)*arg3);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1LoadSearch(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  STRING *arg2 = 0 ;
  STRING temp2 ;
  QUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      temp2 = rtn;
      arg2 = &temp2;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      temp2 = rtn;
      arg2 = &temp2;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    temp2 = arg2_pstr;
    arg2 = &temp2;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
  }
#endif
  
  result = (QUERY *)IRSET_LoadSearch(arg1,(STRING const &)*arg2);
  *(QUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1GetRset_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  unsigned int arg2 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (RSET *)((IRSET const *)arg1)->GetRset(arg2);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1GetRset_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  result = (RSET *)((IRSET const *)arg1)->GetRset();
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Fill_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (unsigned int)jarg3; 
  result = (RSET *)((IRSET const *)arg1)->Fill(arg2,arg3);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Fill_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  unsigned int arg2 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (RSET *)((IRSET const *)arg1)->Fill(arg2);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1GetTotalEntries(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  result = (unsigned int)((IRSET const *)arg1)->GetTotalEntries();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1GetHitTotal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  result = (unsigned int)(arg1)->GetHitTotal();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Or(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Or((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Nor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Nor((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1And(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->And((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Nand(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Nand((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1AndNot(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->AndNot((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Xor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Xor((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Near(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Near((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Far(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Far((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1After(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->After((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Before(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Before((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Adj(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Adj((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Follows(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Follows((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Precedes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Precedes((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Neighbor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Neighbor((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Peer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Peer((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1BeforePeer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->BeforePeer((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1AfterPeer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->AfterPeer((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1XPeer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->XPeer((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Within_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  char *arg2 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (IRSET *)(arg1)->Within((char const *)arg2);
  *(IRSET **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Within_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (IRSET *)(arg1)->Within(*arg2,(char const *)arg3);
  *(IRSET **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1BeforeWithin(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (IRSET *)(arg1)->BeforeWithin(*arg2,(char const *)arg3);
  *(IRSET **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1AfterWithin(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (IRSET *)(arg1)->AfterWithin(*arg2,(char const *)arg3);
  *(IRSET **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1XWithin(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  char *arg2 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (IRSET *)(arg1)->XWithin((char const *)arg2);
  *(IRSET **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Inside(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  char *arg2 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (IRSET *)(arg1)->Inside((char const *)arg2);
  *(IRSET **)&jresult = result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXChars_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  float arg3 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = (IRSET *)(arg1)->WithinXChars((IRSET const &)*arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXChars_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->WithinXChars((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXChars_1Before_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  float arg3 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = (IRSET *)(arg1)->WithinXChars_Before((IRSET const &)*arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXChars_1Before_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->WithinXChars_Before((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXChars_1After_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  float arg3 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = (IRSET *)(arg1)->WithinXChars_After((IRSET const &)*arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXChars_1After_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->WithinXChars_After((IRSET const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXPercent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  float arg3 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = (IRSET *)(arg1)->WithinXPercent((IRSET const &)*arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXPercent_1Before(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  float arg3 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = (IRSET *)(arg1)->WithinXPercent_Before((IRSET const &)*arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1WithinXPercent_1After(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *arg2 = 0 ;
  float arg3 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = *(IRSET **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "IRSET const & reference is null");
    return 0;
  } 
  arg3 = (float)jarg3; 
  result = (IRSET *)(arg1)->WithinXPercent_After((IRSET const &)*arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Not(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  result = (IRSET *)(arg1)->Not();
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Reduce_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  int arg2 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (IRSET *)(arg1)->Reduce(arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IRSET_1Reduce_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  result = (IRSET *)(arg1)->Reduce();
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IRSET_1ComputeScores(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IRSET *arg1 = (IRSET *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = (int)jarg2; 
  (arg1)->ComputeScores(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IRSET_1SortBy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IRSET *arg1 = (IRSET *) 0 ;
  enum SortBy arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  arg2 = (enum SortBy)jarg2; 
  (arg1)->SortBy(arg2);
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_IRSET_1GetMaxScore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  result = (double)((IRSET const *)arg1)->GetMaxScore();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_IRSET_1GetMinScore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  IRSET *arg1 = (IRSET *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IRSET **)&jarg1; 
  result = (double)((IRSET const *)arg1)->GetMinScore();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1IRSET(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  IRSET *arg1 = (IRSET *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(IRSET **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RSET_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  jlong jresult = 0 ;
  unsigned int arg1 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (unsigned int)jarg1; 
  result = (RSET *)new RSET(arg1);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RSET_1_1SWIG_11(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (RSET *)new RSET();
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1getself(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  {
    RSET &_result_ref = RSET_getself(arg1);
    result = (RSET *) &_result_ref;
  }
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RSET_1Write(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RSET *arg1 = (RSET *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  RSET_Write(arg1,(char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_RSET_1Read(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RSET *arg1 = (RSET *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  RSET_Read(arg1,(char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1Cat(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  RSET arg2 ;
  RSET const *argp2 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RSET **)&jarg1; 
  argp2 = *(RSET **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RSET const");
    return 0;
  }
  arg2 = *argp2; 
  {
    RSET &_result_ref = (arg1)->Cat(arg2);
    result = (RSET *) &_result_ref;
  }
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RSET_1LoadTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RSET *arg1 = (RSET *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->LoadTable(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_RSET_1SaveTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RSET *arg1 = (RSET *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  ((RSET const *)arg1)->SaveTable(arg2);
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_RSET_1GetMaxScore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  result = (double)((RSET const *)arg1)->GetMaxScore();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_RSET_1GetMinScore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  result = (double)((RSET const *)arg1)->GetMinScore();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_RSET_1FilterDateRange(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  SwigValueWrapper< DATERANGE > arg2 ;
  DATERANGE const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RSET **)&jarg1; 
  argp2 = *(DATERANGE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DATERANGE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->FilterDateRange(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1GetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  unsigned int arg2 ;
  RESULT result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = ((RSET const *)arg1)->GetEntry(arg2);
  *(RESULT **)&jresult = new RESULT((const RESULT &)result); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RSET_1GetScaledScore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2, jint jarg3) {
  jint jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  double arg2 ;
  int arg3 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (double)jarg2; 
  arg3 = (int)jarg3; 
  result = (int)(arg1)->GetScaledScore(arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1GetHitTotal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  result = (unsigned int)((RSET const *)arg1)->GetHitTotal();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1Find(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  char *arg2 = (char *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (unsigned int)((RSET const *)arg1)->Find((char const *)arg2);
  jresult = (jlong)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1GetTotalEntries(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalEntries();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RSET_1SortBy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  RSET *arg1 = (RSET *) 0 ;
  enum SortBy arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (enum SortBy)jarg2; 
  (arg1)->SortBy(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_RSET_1SortByCategoryMagnetism(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  RSET *arg1 = (RSET *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (double)jarg2; 
  (arg1)->SortByCategoryMagnetism(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1Reduce(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  int arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (unsigned int)(arg1)->Reduce(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1DropByTerms(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  size_t arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (size_t)jarg2; 
  result = (unsigned int)(arg1)->DropByTerms(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1DropByScore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  double arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (double)jarg2; 
  result = (unsigned int)(arg1)->DropByScore(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RSET_1_1_1getitem_1_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  RSET *arg1 = (RSET *) 0 ;
  int arg2 ;
  RESULT result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RSET **)&jarg1; 
  arg2 = (int)jarg2; 
  result = RSET___getitem__(arg1,arg2);
  *(RESULT **)&jresult = new RESULT((const RESULT &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1RSET(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  RSET *arg1 = (RSET *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(RSET **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1INFIX2RPN(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  INFIX2RPN *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (INFIX2RPN *)new INFIX2RPN();
  *(INFIX2RPN **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_INFIX2RPN_1Parse(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  INFIX2RPN *arg1 = (INFIX2RPN *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INFIX2RPN **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->Parse(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_INFIX2RPN_1InputParsedOK(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  INFIX2RPN *arg1 = (INFIX2RPN *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INFIX2RPN **)&jarg1; 
  result = (bool)((INFIX2RPN const *)arg1)->InputParsedOK();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_INFIX2RPN_1GetErrorMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  INFIX2RPN *arg1 = (INFIX2RPN *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INFIX2RPN **)&jarg1; 
  result = ((INFIX2RPN const *)arg1)->GetErrorMessage();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1INFIX2RPN(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  INFIX2RPN *arg1 = (INFIX2RPN *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(INFIX2RPN **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1THESAURUS_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  THESAURUS *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (THESAURUS *)new THESAURUS();
  *(THESAURUS **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1THESAURUS_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  STRING arg1 ;
  THESAURUS *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = (THESAURUS *)new THESAURUS(arg1);
  *(THESAURUS **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1THESAURUS_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jstring jarg1, jstring jarg2, jboolean jarg3) {
  jlong jresult = 0 ;
  STRING arg1 ;
  STRING arg2 ;
  bool arg3 ;
  THESAURUS *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = jarg3 ? true : false; 
  result = (THESAURUS *)new THESAURUS(arg1,arg2,arg3);
  *(THESAURUS **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_THESAURUS_1Compile_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jboolean jarg4) {
  jboolean jresult = 0 ;
  THESAURUS *arg1 = (THESAURUS *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  bool arg4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(THESAURUS **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  arg4 = jarg4 ? true : false; 
  result = (bool)(arg1)->Compile(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_THESAURUS_1Compile_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jboolean jresult = 0 ;
  THESAURUS *arg1 = (THESAURUS *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(THESAURUS **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->Compile(arg2,arg3);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_THESAURUS_1SetFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  THESAURUS *arg1 = (THESAURUS *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(THESAURUS **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetFileName(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1THESAURUS(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  THESAURUS *arg1 = (THESAURUS *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(THESAURUS **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1OPERATOR(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  OPERATOR *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (OPERATOR *)new OPERATOR();
  *(OPERATOR **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_OPERATOR_1GetOpType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  t_OpType result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OPERATOR **)&jarg1; 
  result = ((OPERATOR const *)arg1)->GetOpType();
  *(t_OpType **)&jresult = new t_OpType((const t_OpType &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_OPERATOR_1SetOperatorType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  t_Operator arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OPERATOR **)&jarg1; 
  arg2 = (t_Operator)jarg2; 
  (arg1)->SetOperatorType(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_OPERATOR_1GetOperatorType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  t_Operator result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OPERATOR **)&jarg1; 
  result = (t_Operator)((OPERATOR const *)arg1)->GetOperatorType();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_OPERATOR_1SetOperatorMetric(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  float arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OPERATOR **)&jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->SetOperatorMetric(arg2);
}


SWIGEXPORT jfloat JNICALL Java_IBJNI_OPERATOR_1GetOperatorMetric(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jfloat jresult = 0 ;
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  float result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OPERATOR **)&jarg1; 
  result = (float)((OPERATOR const *)arg1)->GetOperatorMetric();
  jresult = (jfloat)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_OPERATOR_1SetOperatorString(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OPERATOR **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SetOperatorString((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_OPERATOR_1GetOperatorString(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OPERATOR **)&jarg1; 
  result = ((OPERATOR const *)arg1)->GetOperatorString();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1OPERATOR(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  OPERATOR *arg1 = (OPERATOR *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(OPERATOR **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jint JNICALL Java_IBJNI_QueryAutodetect_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  QueryTypeMethods result;
  
  (void)jenv;
  (void)jcls;
  result = (QueryTypeMethods)QueryAutodetect;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SQUERY_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (SQUERY *)new SQUERY();
  *(SQUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SQUERY_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SQUERY arg1 ;
  SQUERY *argp1 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(SQUERY **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SQUERY");
    return 0;
  }
  arg1 = *argp1; 
  result = (SQUERY *)new SQUERY(arg1);
  *(SQUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SQUERY_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jstring jarg1, jint jarg2, jlong jarg3, jobject jarg3_) {
  jlong jresult = 0 ;
  STRING arg1 ;
  enum QueryTypeMethods arg2 ;
  THESAURUS *arg3 = (THESAURUS *) 0 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg3_;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  arg2 = (enum QueryTypeMethods)jarg2; 
  arg3 = *(THESAURUS **)&jarg3; 
  result = (SQUERY *)new SQUERY(arg1,arg2,arg3);
  *(SQUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SQUERY_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jstring jarg1, jint jarg2) {
  jlong jresult = 0 ;
  STRING arg1 ;
  enum QueryTypeMethods arg2 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  arg2 = (enum QueryTypeMethods)jarg2; 
  result = (SQUERY *)new SQUERY(arg1,arg2);
  *(SQUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SQUERY_1_1SWIG_14(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  STRING arg1 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = (SQUERY *)new SQUERY(arg1);
  *(SQUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1GetTotalTerms(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  result = (unsigned int)((SQUERY const *)arg1)->GetTotalTerms();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SQUERY_1SetOperator(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  OPERATOR *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SQUERY **)&jarg1; 
  arg2 = *(OPERATOR **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "OPERATOR const & reference is null");
    return 0;
  } 
  result = (bool)(arg1)->SetOperator((OPERATOR const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SQUERY_1SetOperatorAndWithin(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (bool)(arg1)->SetOperatorAndWithin((char const *)arg2);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SQUERY_1SetOperatorNear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  result = (bool)(arg1)->SetOperatorNear();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SQUERY_1SetOperatorPeer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  result = (bool)(arg1)->SetOperatorPeer();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetAttributes_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jboolean jarg3) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  ATTRLIST *arg2 = 0 ;
  bool arg3 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  arg2 = *(ATTRLIST **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "ATTRLIST const & reference is null");
    return 0;
  } 
  arg3 = jarg3 ? true : false; 
  result = (unsigned int)(arg1)->SetAttributes((ATTRLIST const &)*arg2,arg3);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetAttributes_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  ATTRLIST *arg2 = 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  arg2 = *(ATTRLIST **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "ATTRLIST const & reference is null");
    return 0;
  } 
  result = (unsigned int)(arg1)->SetAttributes((ATTRLIST const &)*arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SQUERY_1isPlainQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  result = (bool)((SQUERY const *)arg1)->isPlainQuery();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SQUERY_1isOpQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  t_Operator arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  arg2 = (t_Operator)jarg2; 
  result = (bool)((SQUERY const *)arg1)->isOpQuery(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetRelevantTerm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)(arg1)->SetRelevantTerm(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetInfixTerm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)(arg1)->SetInfixTerm(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetRpnTerm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)(arg1)->SetRpnTerm(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetQueryTerm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)(arg1)->SetQueryTerm(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetQueryTermUTF(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING *arg2 = 0 ;
  STRING temp2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      temp2 = rtn;
      arg2 = &temp2;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      temp2 = rtn;
      arg2 = &temp2;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    temp2 = arg2_pstr;
    arg2 = &temp2;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
  }
#endif
  
  result = (unsigned int)(arg1)->SetQueryTermUTF((STRING const &)*arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetWords_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  int arg3 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  result = (unsigned int)(arg1)->SetWords(arg2,arg3);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetWords_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)(arg1)->SetWords(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetWordsAnd_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  int arg3 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  result = (unsigned int)SQUERY_SetWordsAnd__SWIG_0(arg1,arg2,arg3);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetWordsAnd_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)SQUERY_SetWordsAnd__SWIG_0(arg1,arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetWords_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_, jint jarg4) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  OPERATOR *arg3 = 0 ;
  int arg4 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = *(OPERATOR **)&jarg3;
  if(!arg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "OPERATOR const & reference is null");
    return 0;
  } 
  arg4 = (int)jarg4; 
  result = (arg1)->SetWords(arg2,(OPERATOR const &)*arg3,arg4);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetWords_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  OPERATOR *arg3 = 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = *(OPERATOR **)&jarg3;
  if(!arg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "OPERATOR const & reference is null");
    return 0;
  } 
  result = (arg1)->SetWords(arg2,(OPERATOR const &)*arg3);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetFreeFormWords_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  int arg3 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  result = (arg1)->SetFreeFormWords(arg2,arg3);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetFreeFormWords_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->SetFreeFormWords(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1SetFreeFormWordsPhonetic(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  int arg3 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  result = (arg1)->SetFreeFormWordsPhonetic(arg2,arg3);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SQUERY_1LastErrorMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  result = ((SQUERY const *)arg1)->LastErrorMessage();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SQUERY_1GetRpnTerm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  result = ((SQUERY const *)arg1)->GetRpnTerm();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1Cat_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  SQUERY arg2 ;
  SQUERY const *argp2 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SQUERY **)&jarg1; 
  argp2 = *(SQUERY **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SQUERY const");
    return 0;
  }
  arg2 = *argp2; 
  {
    SQUERY &_result_ref = (arg1)->Cat(arg2);
    result = (SQUERY *) &_result_ref;
  }
  *(SQUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SQUERY_1Cat_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  SQUERY *arg1 = (SQUERY *) 0 ;
  SQUERY arg2 ;
  char *arg3 = (char *) 0 ;
  SQUERY const *argp2 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SQUERY **)&jarg1; 
  argp2 = *(SQUERY **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SQUERY const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  {
    SQUERY &_result_ref = (arg1)->Cat(arg2,(char const *)arg3);
    result = (SQUERY *) &_result_ref;
  }
  *(SQUERY **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_SQUERY_1OpenThesaurus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  SQUERY *arg1 = (SQUERY *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->OpenThesaurus(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_SQUERY_1CloseThesaurus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  SQUERY *arg1 = (SQUERY *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  (arg1)->CloseThesaurus();
}


SWIGEXPORT void JNICALL Java_IBJNI_SQUERY_1ExpandQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  SQUERY *arg1 = (SQUERY *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SQUERY **)&jarg1; 
  (arg1)->ExpandQuery();
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1SQUERY(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  SQUERY *arg1 = (SQUERY *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(SQUERY **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1QUERY(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  QUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (QUERY *)new QUERY();
  *(QUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_QUERY_1SetSQUERY(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  QUERY *arg1 = (QUERY *) 0 ;
  SQUERY *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(QUERY **)&jarg1; 
  arg2 = *(SQUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "SQUERY const & reference is null");
    return ;
  } 
  (arg1)->SetSQUERY((SQUERY const &)*arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_QUERY_1GetSQUERY(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  QUERY *arg1 = (QUERY *) 0 ;
  SQUERY *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(QUERY **)&jarg1; 
  {
    SQUERY const &_result_ref = ((QUERY const *)arg1)->GetSQUERY();
    result = (SQUERY *) &_result_ref;
  }
  *(SQUERY **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_QUERY_1SetNormalizationMethod(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  QUERY *arg1 = (QUERY *) 0 ;
  enum NormalizationMethods arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(QUERY **)&jarg1; 
  arg2 = (enum NormalizationMethods)jarg2; 
  (arg1)->SetNormalizationMethod(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_QUERY_1GetNormalizationMethod(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  QUERY *arg1 = (QUERY *) 0 ;
  enum NormalizationMethods result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(QUERY **)&jarg1; 
  result = (enum NormalizationMethods)((QUERY const *)arg1)->GetNormalizationMethod();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_QUERY_1SetSortBy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  QUERY *arg1 = (QUERY *) 0 ;
  enum SortBy arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(QUERY **)&jarg1; 
  arg2 = (enum SortBy)jarg2; 
  (arg1)->SetSortBy(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_QUERY_1GetSortBy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  QUERY *arg1 = (QUERY *) 0 ;
  enum SortBy result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(QUERY **)&jarg1; 
  result = (enum SortBy)((QUERY const *)arg1)->GetSortBy();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_QUERY_1GetMaximumResults(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  QUERY *arg1 = (QUERY *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(QUERY **)&jarg1; 
  result = (unsigned int)((QUERY const *)arg1)->GetMaximumResults();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_QUERY_1SetMaximumResults(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  QUERY *arg1 = (QUERY *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(QUERY **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetMaximumResults(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1QUERY(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  QUERY *arg1 = (QUERY *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(QUERY **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SRCH_1DATE_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  SRCH_DATE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  result = (SRCH_DATE *)new SRCH_DATE((char const *)arg1);
  *(SRCH_DATE **)&jresult = result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SRCH_1DATE_1_1SWIG_11(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  SRCH_DATE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (SRCH_DATE *)new SRCH_DATE();
  *(SRCH_DATE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SRCH_1DATE_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jdouble jarg1) {
  jlong jresult = 0 ;
  double arg1 ;
  SRCH_DATE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (double)jarg1; 
  result = (SRCH_DATE *)new SRCH_DATE(arg1);
  *(SRCH_DATE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SRCH_1DATE_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  long arg1 ;
  SRCH_DATE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (long)jarg1; 
  result = (SRCH_DATE *)new SRCH_DATE(arg1);
  *(SRCH_DATE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1Plus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Plus(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1Minus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Minus(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1PlusNseconds(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->PlusNseconds(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1PlusNminutes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->PlusNminutes(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1PlusNhours(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->PlusNhours(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1PlusNdays(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->PlusNdays(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1PlusNweeks(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->PlusNweeks(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1PlusNmonths(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->PlusNmonths(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1PlusNyears(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->PlusNyears(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1MinusNseconds(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->MinusNseconds(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1MinusNminutes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->MinusNminutes(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1MinusNhours(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->MinusNhours(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1MinusNdays(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->MinusNdays(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1MinusNweeks(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->MinusNweeks(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1MinusNmonths(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->MinusNmonths(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1MinusNyears(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->MinusNyears(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1Tommorrow(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->Tommorrow();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1Yesterday(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->Yesterday();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1NextWeek(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->NextWeek();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1LastWeek(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->LastWeek();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1NextMonth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->NextMonth();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1LastMonth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->LastMonth();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1NextYear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->NextYear();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1LastYear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->LastYear();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_SRCH_1DATE_1GetValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (double)(arg1)->GetValue();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsYearDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->IsYearDate();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsMonthDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->IsMonthDate();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsDayDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->IsDayDate();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsBogusDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->IsBogusDate();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsValidDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->IsValidDate();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsLeapYear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->IsLeapYear();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1Ok(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->Ok();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1TrimToMonth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->TrimToMonth();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1TrimToYear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->TrimToYear();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetToYearStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->SetToYearStart();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetToYearEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->SetToYearEnd();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetToMonthStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->SetToMonthStart();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetToMonthEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->SetToMonthEnd();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetToDayStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->SetToDayStart();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetToDayEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->SetToDayEnd();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1PromoteToMonthStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->PromoteToMonthStart();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1PromoteToMonthEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->PromoteToMonthEnd();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1PromoteToDayStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->PromoteToDayStart();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1PromoteToDayEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (bool)(arg1)->PromoteToDayEnd();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_SRCH_1DATE_1GetTodaysDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  (arg1)->GetTodaysDate();
}


SWIGEXPORT void JNICALL Java_IBJNI_SRCH_1DATE_1SetNow(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  (arg1)->SetNow();
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetYear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (bool)(arg1)->SetYear(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetMonth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (bool)(arg1)->SetMonth(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetDay(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (bool)(arg1)->SetDay(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1Year(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->Year();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1Month(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->Month();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1Day(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->Day();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1DayOfWeek(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->DayOfWeek();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1DayOfYear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->DayOfYear();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1GetFirstDayOfMonth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->GetFirstDayOfMonth();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1GetWeekOfMonth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->GetWeekOfMonth();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1WeekOfYear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->WeekOfYear();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1GetDaysInMonth(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (int)(arg1)->GetDaysInMonth();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1GetJulianDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (long)(arg1)->GetJulianDate();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_SRCH_1DATE_1GetTimeSeconds(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (long)(arg1)->GetTimeSeconds();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetTimeOfFile(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->SetTimeOfFile(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1SetTimeOfFileCreation(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->SetTimeOfFileCreation(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1GetTimeOfFile(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->GetTimeOfFile(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SRCH_1DATE_1GetTimeOfFileCreation(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING arg2 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->GetTimeOfFileCreation(arg2);
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsBefore(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->IsBefore(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1Equals(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->Equals(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsDuring(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->IsDuring(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SRCH_1DATE_1IsAfter(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->IsAfter(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SRCH_1DATE_1ISOdate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->ISOdate();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SRCH_1DATE_1RFCdate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->RFCdate();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SRCH_1DATE_1ANSIdate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->ANSIdate();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SRCH_1DATE_1LCdate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  result = (arg1)->LCdate();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SRCH_1DATE_1Strftime(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  char *arg2 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SRCH_DATE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = SRCH_DATE_Strftime(arg1,(char const *)arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1SRCH_1DATE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  SRCH_DATE *arg1 = (SRCH_DATE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(SRCH_DATE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DATERANGE(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  SRCH_DATE arg1 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp1 ;
  SRCH_DATE const *argp2 ;
  DATERANGE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  argp1 = *(SRCH_DATE **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return 0;
  }
  arg1 = *argp1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (DATERANGE *)new DATERANGE(arg1,arg2);
  *(DATERANGE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DATERANGE_1GetStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  result = (arg1)->GetStart();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_DATERANGE_1GetEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  result = (arg1)->GetEnd();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_DATERANGE_1SetStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DATERANGE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetStart(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_DATERANGE_1SetEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DATERANGE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetEnd(arg2);
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DATERANGE_1Ok(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  result = (bool)(arg1)->Ok();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DATERANGE_1Defined(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  result = (bool)(arg1)->Defined();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DATERANGE_1Contains(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DATERANGE **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->Contains(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DATERANGE_1ISO(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  result = DATERANGE_ISO(arg1);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DATERANGE_1RFC(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  result = DATERANGE_RFC(arg1);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DATERANGE_1Strftime_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jstring jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = DATERANGE_Strftime__SWIG_0(arg1,(char const *)arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DATERANGE_1Strftime_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  char *arg2 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = DATERANGE_Strftime__SWIG_0(arg1,(char const *)arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1DATERANGE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(DATERANGE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_DATERANGE_1Duration(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  DATERANGE *arg1 = (DATERANGE *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DATERANGE **)&jarg1; 
  result = (double)DATERANGE_Duration(arg1);
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SCANOBJ(JNIEnv *jenv, jclass jcls, jstring jarg1, jlong jarg2) {
  jlong jresult = 0 ;
  STRING arg1 ;
  unsigned int arg2 ;
  SCANOBJ *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  arg2 = (unsigned int)jarg2; 
  result = (SCANOBJ *)new SCANOBJ(arg1,arg2);
  *(SCANOBJ **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SCANOBJ_1Frequency(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SCANOBJ *arg1 = (SCANOBJ *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SCANOBJ **)&jarg1; 
  result = (unsigned int)((SCANOBJ const *)arg1)->Frequency();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_SCANOBJ_1Term(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  SCANOBJ *arg1 = (SCANOBJ *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SCANOBJ **)&jarg1; 
  result = ((SCANOBJ const *)arg1)->Term();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1SCANOBJ(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  SCANOBJ *arg1 = (SCANOBJ *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(SCANOBJ **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1SCANLIST(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SwigValueWrapper< SCANLIST > arg1 ;
  SCANLIST const *argp1 ;
  SCANLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  argp1 = *(SCANLIST **)&jarg1; 
  if (!argp1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SCANLIST const");
    return 0;
  }
  arg1 = *argp1; 
  result = (SCANLIST *)new SCANLIST(arg1);
  *(SCANLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_SCANLIST_1Reverse(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  SCANLIST *arg1 = (SCANLIST *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SCANLIST **)&jarg1; 
  (arg1)->Reverse();
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_SCANLIST_1IsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  SCANLIST *arg1 = (SCANLIST *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SCANLIST **)&jarg1; 
  result = (bool)(arg1)->IsEmpty();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SCANLIST_1GetTotalEntries(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  SCANLIST *arg1 = (SCANLIST *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SCANLIST **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalEntries();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SCANLIST_1GetEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  SCANLIST *arg1 = (SCANLIST *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper< SCANOBJ > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(SCANLIST **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (arg1)->GetEntry(arg2);
  *(SCANOBJ **)&jresult = new SCANOBJ((const SCANOBJ &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1SCANLIST(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  SCANLIST *arg1 = (SCANLIST *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(SCANLIST **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DOCTYPE_1ID(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  DOCTYPE_ID *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  result = (DOCTYPE_ID *)new DOCTYPE_ID((char const *)arg1);
  *(DOCTYPE_ID **)&jresult = result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DOCTYPE_1ID_1DocumentType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  DOCTYPE_ID *arg1 = (DOCTYPE_ID *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOCTYPE_ID **)&jarg1; 
  result = ((DOCTYPE_ID const *)arg1)->DocumentType();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_DOCTYPE_1ID_1Set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  DOCTYPE_ID *arg1 = (DOCTYPE_ID *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOCTYPE_ID **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->Set(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DOCTYPE_1ID_1Get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  DOCTYPE_ID *arg1 = (DOCTYPE_ID *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOCTYPE_ID **)&jarg1; 
  result = ((DOCTYPE_ID const *)arg1)->Get();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DOCTYPE_1ID_1c_1str(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  DOCTYPE_ID *arg1 = (DOCTYPE_ID *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOCTYPE_ID **)&jarg1; 
  result = (char *)((DOCTYPE_ID const *)arg1)->c_str();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DOCTYPE_1ID_1IsDefined(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  DOCTYPE_ID *arg1 = (DOCTYPE_ID *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOCTYPE_ID **)&jarg1; 
  result = (bool)((DOCTYPE_ID const *)arg1)->IsDefined();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DOCTYPE_1ID_1Equals(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  DOCTYPE_ID *arg1 = (DOCTYPE_ID *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > arg2 ;
  DOCTYPE_ID const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DOCTYPE_ID **)&jarg1; 
  argp2 = *(DOCTYPE_ID **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DOCTYPE_ID const");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->Equals(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1DOCTYPE_1ID(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  DOCTYPE_ID *arg1 = (DOCTYPE_ID *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(DOCTYPE_ID **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1DOC_1ID(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  DOC_ID *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  result = (DOC_ID *)new DOC_ID((char const *)arg1);
  *(DOC_ID **)&jresult = result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_DOC_1ID_1Equals(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  DOC_ID *arg1 = (DOC_ID *) 0 ;
  DOC_ID *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DOC_ID **)&jarg1; 
  arg2 = *(DOC_ID **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "DOC_ID const & reference is null");
    return 0;
  } 
  result = (bool)(arg1)->Equals((DOC_ID const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_DOC_1ID_1Compare(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  DOC_ID *arg1 = (DOC_ID *) 0 ;
  DOC_ID *arg2 = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(DOC_ID **)&jarg1; 
  arg2 = *(DOC_ID **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "DOC_ID const & reference is null");
    return 0;
  } 
  result = (int)(arg1)->Compare((DOC_ID const &)*arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DOC_1ID_1GlobalKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  DOC_ID *arg1 = (DOC_ID *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(DOC_ID **)&jarg1; 
  result = (arg1)->GlobalKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1DOC_1ID(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  DOC_ID *arg1 = (DOC_ID *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(DOC_ID **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RECORD_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  RECORD *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (RECORD *)new RECORD();
  *(RECORD **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RECORD_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  STRING arg1 ;
  RECORD *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = (RECORD *)new RECORD(arg1);
  *(RECORD **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1RECORD_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = 0 ;
  RECORD *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1;
  if(!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RECORD const & reference is null");
    return 0;
  } 
  result = (RECORD *)new RECORD((RECORD const &)*arg1);
  *(RECORD **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetKey(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORD_1GetKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetPath(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORD_1GetPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetPath();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetFileName(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORD_1GetFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetFileName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetFullFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetFullFileName(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_RECORD_1GetFullFileName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetFullFileName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetRecordStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetRecordStart(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetRecordStart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = (unsigned int)((RECORD const *)arg1)->GetRecordStart();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetRecordEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetRecordEnd(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetRecordEnd(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = (unsigned int)((RECORD const *)arg1)->GetRecordEnd();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetDocumentType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  RECORD *arg1 = (RECORD *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > arg2 ;
  DOCTYPE_ID const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RECORD **)&jarg1; 
  argp2 = *(DOCTYPE_ID **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DOCTYPE_ID const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDocumentType(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetDocumentType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetDocumentType();
  *(DOCTYPE_ID **)&jresult = new DOCTYPE_ID((const DOCTYPE_ID &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetLocale(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  LOCALE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetLocale();
  *(LOCALE **)&jresult = new LOCALE((const LOCALE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetLocale(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  RECORD *arg1 = (RECORD *) 0 ;
  LOCALE arg2 ;
  LOCALE const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RECORD **)&jarg1; 
  argp2 = *(LOCALE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null LOCALE const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetLocale(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetLanguage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SetLanguage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetCharset(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SetCharset((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetDate();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetDate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RECORD **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDate(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetDateModified(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RECORD **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDateModified(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetDateModified(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetDateModified();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetDateCreated(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RECORD **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDateCreated(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetDateCreated(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetDateCreated();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RECORD_1GetPriority(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = (int)((RECORD const *)arg1)->GetPriority();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetPriority(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  arg2 = (int)jarg2; 
  (arg1)->SetPriority(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_RECORD_1GetCategory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = (int)((RECORD const *)arg1)->GetCategory();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetCategory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  RECORD *arg1 = (RECORD *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  arg2 = (int)jarg2; 
  (arg1)->SetCategory(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_RECORD_1_1_1len_1_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = (int)RECORD___len__(arg1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_RECORD_1SetDateExpires(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RECORD **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetDateExpires(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_RECORD_1GetDateExpires(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = ((RECORD const *)arg1)->GetDateExpires();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RECORD_1TTL_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(RECORD **)&jarg1; 
  result = (int)((RECORD const *)arg1)->TTL();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_RECORD_1TTL_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jint jresult = 0 ;
  RECORD *arg1 = (RECORD *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE *argp2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(RECORD **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE");
    return 0;
  }
  arg2 = *argp2; 
  result = (int)((RECORD const *)arg1)->TTL(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1RECORD(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  RECORD *arg1 = (RECORD *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(RECORD **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1FCACHE(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDBOBJ *arg1 = (IDBOBJ *) 0 ;
  FCACHE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDBOBJ **)&jarg1; 
  result = (FCACHE *)new FCACHE(arg1);
  *(FCACHE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCACHE_1Ok(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCACHE **)&jarg1; 
  result = (bool)((FCACHE const *)arg1)->Ok();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCACHE_1ValidateInField_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jboolean jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  GPTYPE arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCACHE **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE const)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  result = (bool)(arg1)->ValidateInField(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCACHE_1ValidateInField_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  FC arg2 ;
  FC const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(FCACHE **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC const");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->ValidateInField(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCACHE_1ValidateInField_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jstring jarg3) {
  jboolean jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  GPTYPE arg2 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCACHE **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE const)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (bool)((FCACHE const *)arg1)->ValidateInField(arg2,(char const *)arg3);
  jresult = (jboolean)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCACHE_1ValidateInField_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jboolean jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  FC arg2 ;
  char *arg3 = (char *) 0 ;
  FC const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(FCACHE **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (bool)((FCACHE const *)arg1)->ValidateInField(arg2,(char const *)arg3);
  jresult = (jboolean)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_FCACHE_1GetTotal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCACHE **)&jarg1; 
  result = ((FCACHE const *)arg1)->GetTotal();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCACHE_1SetFieldName_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  jboolean jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCACHE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = jarg3 ? true : false; 
  result = (bool)(arg1)->SetFieldName((char const *)arg2,arg3);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_FCACHE_1SetFieldName_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCACHE **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (bool)(arg1)->SetFieldName((char const *)arg2);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_FCACHE_1GetFieldName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  FCACHE *arg1 = (FCACHE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(FCACHE **)&jarg1; 
  result = ((FCACHE const *)arg1)->GetFieldName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1FCACHE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  FCACHE *arg1 = (FCACHE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(FCACHE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jint JNICALL Java_IBJNI_DbStateInvalid_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)(int)DbStateInvalid;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_DbStateReady_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)(int)DbStateReady;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_DbStateBusy_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int)(int)DbStateBusy;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_iNothing_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  MergeStatus result;
  
  (void)jenv;
  (void)jcls;
  result = (MergeStatus)iNothing;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1IDB_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jstring jarg1, jboolean jarg2) {
  jlong jresult = 0 ;
  STRING arg1 ;
  bool arg2 ;
  IDB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  arg2 = jarg2 ? true : false; 
  result = (IDB *)new IDB(arg1,arg2);
  *(IDB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1IDB_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  STRING arg1 ;
  IDB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = (IDB *)new IDB(arg1);
  *(IDB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Open_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = jarg3 ? true : false; 
  result = (bool)(arg1)->Open(arg2,arg3);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Open_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->Open(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Close(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->Close();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDebugMode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetDebugMode(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1FirstKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (arg1)->FirstKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1LastKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (arg1)->LastKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1NextKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->NextKey(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1PrevKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->PrevKey(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetVolume(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  (arg1)->SetVolume(arg2,arg3);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetVolume(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  INT result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetVolume();
  *(INT **)&jresult = new INT((const INT &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetFindConcatWords_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetFindConcatWords(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetFindConcatWords_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  IDB *arg1 = (IDB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  (arg1)->SetFindConcatWords();
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFindConcatWords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GDT_BOOLEAN result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetFindConcatWords();
  *(GDT_BOOLEAN **)&jresult = new GDT_BOOLEAN((const GDT_BOOLEAN &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetSegment_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  (arg1)->SetSegment(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetSegment_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetSegment(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetSegment_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  (arg1)->SetSegment(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetSegmentName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetSegmentName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1Segment(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (int)(arg1)->Segment((char const *)arg2);
  jresult = (jint)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1setUseRelativePaths(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  result = (bool)(arg1)->setUseRelativePaths(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetWorkingDirectory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetWorkingDirectory(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1ClearWorkingDirectoryEntry(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  IDB *arg1 = (IDB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  (arg1)->ClearWorkingDirectoryEntry();
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1SetErrorCode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (int)(arg1)->SetErrorCode(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetErrorCode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (int)((IDB const *)arg1)->GetErrorCode();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1ErrorMessage_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (char *)((IDB const *)arg1)->ErrorMessage();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1ErrorMessage_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (char *)((IDB const *)arg1)->ErrorMessage(arg2);
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1FieldExists(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)((IDB const *)arg1)->FieldExists(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFieldDefinitionList(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (STRLIST *)IDB_GetFieldDefinitionList((IDB const *)arg1);
  *(STRLIST **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetDocumentInfo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  RECORD *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (RECORD *)IDB_GetDocumentInfo(arg1,arg2);
  *(RECORD **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetAllDocTypes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRLIST result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (arg1)->GetAllDocTypes();
  *(STRLIST **)&jresult = new STRLIST((const STRLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetMainMdt(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  MDT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (MDT *)((IDB const *)arg1)->GetMainMdt();
  *(MDT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1DateCreated(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (arg1)->DateCreated();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1DateLastModified(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (arg1)->DateLastModified();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetCommonWordsThreshold(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  long arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (long)jarg2; 
  (arg1)->SetCommonWordsThreshold(arg2);
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1CreateCentroid(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->CreateCentroid();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1SetLocale_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (bool)(arg1)->SetLocale((char const *)arg2);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1SetLocale_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->SetLocale();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1IsDbCompatible(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->IsDbCompatible();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1IsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)((IDB const *)arg1)->IsEmpty();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Ok(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->Ok();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1ffGC(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  IDB *arg1 = (IDB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  (arg1)->ffGC();
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetMergeStatus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  enum MergeStatus arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (enum MergeStatus)jarg2; 
  (arg1)->SetMergeStatus(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDbState(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  IDB_SetDbState((IDB const *)arg1,arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetDbState(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (int)((IDB const *)arg1)->GetDbState();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetIndexBoostFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (double)jarg2; 
  (arg1)->SetIndexBoostFactor(arg2);
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_IDB_1GetIndexBoostFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (double)((IDB const *)arg1)->GetIndexBoostFactor();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetFreshnessBoostFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (double)jarg2; 
  (arg1)->SetFreshnessBoostFactor(arg2);
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_IDB_1GetFreshnessBoostFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (double)((IDB const *)arg1)->GetFreshnessBoostFactor();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetLongevityBoostFattor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (double)jarg2; 
  (arg1)->SetLongevityBoostFattor(arg2);
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_IDB_1GetLongevityBoostFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (double)((IDB const *)arg1)->GetLongevityBoostFactor();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetFreshnessBaseDateLine(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  IDB *arg1 = (IDB *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetFreshnessBaseDateLine(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFreshnessBaseDateLine(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetFreshnessBaseDateLine();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDefaultDbSearchCutoff(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDefaultDbSearchCutoff(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDbSearchCutoff(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDbSearchCutoff(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetDbSearchCutoff(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (unsigned int)((IDB const *)arg1)->GetDbSearchCutoff();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDbSearchFuel(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDbSearchFuel(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDbSearchCacheSize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDbSearchCacheSize(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDefaultPriorityFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (double)jarg2; 
  (arg1)->SetDefaultPriorityFactor(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetPriorityFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (double)jarg2; 
  (arg1)->SetPriorityFactor(arg2);
}


SWIGEXPORT jdouble JNICALL Java_IBJNI_IDB_1GetPriorityFactor(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (double)((IDB const *)arg1)->GetPriorityFactor();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetDbSisLimit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDbSisLimit(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetTitle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetTitle(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetTitle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetTitle();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetComments(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetComments(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetComments(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetComments();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetCopyright(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetCopyright(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetCopyright(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetCopyright();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetMaintainer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return ;
  }
  (arg1)->SetMaintainer((char const *)arg2,(char const *)arg3);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetMaintainer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetMaintainer();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetGlobalDoctype(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  IDB *arg1 = (IDB *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > arg2 ;
  DOCTYPE_ID const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(DOCTYPE_ID **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DOCTYPE_ID const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->SetGlobalDoctype(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetIndexingMemory_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jboolean jarg3) {
  IDB *arg1 = (IDB *) 0 ;
  long arg2 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (long)jarg2; 
  arg3 = jarg3 ? true : false; 
  (arg1)->SetIndexingMemory(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetIndexingMemory_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  long arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (long)jarg2; 
  (arg1)->SetIndexingMemory(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetIndexingMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (long)((IDB const *)arg1)->GetIndexingMemory();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetStoplist(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetStoplist(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetGlobalStoplist(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetGlobalStoplist(arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetGlobalStoplist(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetGlobalStoplist();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetTotalWords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (long)((IDB const *)arg1)->GetTotalWords();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetTotalUniqueWords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (long)((IDB const *)arg1)->GetTotalUniqueWords();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetTotalRecords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (unsigned int)((IDB const *)arg1)->GetTotalRecords();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetTotalDocumentsDeleted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (unsigned int)((IDB const *)arg1)->GetTotalDocumentsDeleted();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFieldCache(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FCACHE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (FCACHE *)(arg1)->GetFieldCache();
  *(FCACHE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetPeerFc_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  STRING *arg3 = (STRING *) 0 ;
  FC result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  arg3 = *(STRING **)&jarg3; 
  result = (arg1)->GetPeerFc(arg2,arg3);
  *(FC **)&jresult = new FC((const FC &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetPeerFc_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  FC result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  result = (arg1)->GetPeerFc(arg2);
  *(FC **)&jresult = new FC((const FC &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetPeerFc_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC arg2 ;
  STRING *arg3 = (STRING *) 0 ;
  FC *argp2 ;
  FC result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = *(STRING **)&jarg3; 
  result = (arg1)->GetPeerFc(arg2,arg3);
  *(FC **)&jresult = new FC((const FC &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetPeerFc_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC arg2 ;
  FC *argp2 ;
  FC result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->GetPeerFc(arg2);
  *(FC **)&jresult = new FC((const FC &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetFieldName_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  result = IDB_GetFieldName__SWIG_0(arg1,arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetFieldName_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC arg2 ;
  FC *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg2 = *argp2; 
  result = IDB_GetFieldName__SWIG_1(arg1,arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetPeerNode_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE *arg2 = 0 ;
  GPTYPE temp2 ;
  TREENODE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = &temp2;
    temp2 = 0;
    for(i=0; i<sz; i++) {
      temp2 = (temp2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  result = (arg1)->GetPeerNode((GPTYPE const &)*arg2);
  *(TREENODE **)&jresult = new TREENODE((const TREENODE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetPeerNode_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC *arg2 = 0 ;
  TREENODE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(FC **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "FC const & reference is null");
    return 0;
  } 
  result = (arg1)->GetPeerNode((FC const &)*arg2);
  *(TREENODE **)&jresult = new TREENODE((const TREENODE &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetPeerContent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC arg2 ;
  FC *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->GetPeerContent(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetPeerContentXMLFragement(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC arg2 ;
  FC *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->GetPeerContentXMLFragement(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetNodeTree_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  NODETREE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  result = (arg1)->GetNodeTree(arg2);
  *(NODETREE **)&jresult = new NODETREE((const NODETREE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetNodeTree_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC arg2 ;
  FC *argp2 ;
  NODETREE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->GetNodeTree(arg2);
  *(NODETREE **)&jresult = new NODETREE((const NODETREE &)result); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1KillCache(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)((IDB const *)arg1)->KillCache();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1FillHeadlineCache_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->FillHeadlineCache();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1FillHeadlineCache_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (bool)(arg1)->FillHeadlineCache((char const *)arg2);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1IsSystemFile(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (bool)(arg1)->IsSystemFile((char const *)arg2);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetServerName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SetServerName((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetServerName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetServerName();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1MergeIndexFiles(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->MergeIndexFiles();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1CollapseIndexFiles(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->CollapseIndexFiles();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1DeleteExpired_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (arg1)->DeleteExpired();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1DeleteExpired_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  SRCH_DATE arg2 ;
  SRCH_DATE const *argp2 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(SRCH_DATE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SRCH_DATE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->DeleteExpired(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1KillAll(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->KillAll();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetVersionID(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = ((IDB const *)arg1)->GetVersionID();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1ParseRecords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  IDB *arg1 = (IDB *) 0 ;
  RECORD arg2 ;
  RECORD const *argp2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RECORD **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RECORD const");
    return ;
  }
  arg2 = *argp2; 
  (arg1)->ParseRecords(arg2);
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1AddRecord_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RECORD arg2 ;
  RECORD const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RECORD **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RECORD const");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->AddRecord(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Index_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  result = (bool)(arg1)->Index(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Index_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->Index();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Index1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->Index1();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1Index2(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)(arg1)->Index2();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1AddRecord_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)IDB_AddRecord__SWIG_1(arg1,arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1AppendToIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RECORD arg2 ;
  RECORD const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RECORD **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RECORD const");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)IDB_AppendToIndex(arg1,arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1AppendFileToIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)IDB_AppendFileToIndex(arg1,arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1IsStopWord(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)((IDB const *)arg1)->IsStopWord(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1MdtLookupKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (unsigned int)((IDB const *)arg1)->MdtLookupKey(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1GetDocumentDeleted(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (bool)((IDB const *)arg1)->GetDocumentDeleted(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1DeleteByIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (bool)(arg1)->DeleteByIndex(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1DeleteByKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->DeleteByKey(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1UndeleteByIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (bool)(arg1)->UndeleteByIndex(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1UndeleteByKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->UndeleteByKey(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1SetOverride(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetOverride(arg2);
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1GetOverride(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (bool)((IDB const *)arg1)->GetOverride();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1CleanupDb(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (int)(arg1)->CleanupDb();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetLocks(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = (int)((IDB const *)arg1)->GetLocks();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Scan_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  int arg3 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  result = ((IDB const *)arg1)->Scan(arg2,arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Scan_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jint jarg4) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  int arg4 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  arg4 = (int)jarg4; 
  result = ((IDB const *)arg1)->Scan(arg2,arg3,arg4);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Scan_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  result = ((IDB const *)arg1)->Scan(arg2,arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Scan_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((IDB const *)arg1)->Scan(arg2);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1ScanGlob_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->ScanGlob(arg2);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1ScanGlob_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  int arg3 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  result = (arg1)->ScanGlob(arg2,arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1ScanGlob_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->ScanGlob(arg2,(char const *)arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1ScanGlob_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jint jarg4) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (int)jarg4; 
  result = (arg1)->ScanGlob(arg2,(char const *)arg3,arg4);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1ScanSearch_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jlong jarg4) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  size_t arg4 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (size_t)jarg4; 
  result = (arg1)->ScanSearch((QUERY const &)*arg2,(char const *)arg3,arg4);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1ScanSearch_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->ScanSearch((QUERY const &)*arg2,(char const *)arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1BeginRsetPresent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->BeginRsetPresent((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1EndRsetPresent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  IDB *arg1 = (IDB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->EndRsetPresent((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1BeforeSearching(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  (arg1)->BeforeSearching(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1AfterSearching(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  IRSET *arg2 = (IRSET *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(IRSET **)&jarg2; 
  result = (IRSET *)(arg1)->AfterSearching(arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1BeforeIndexing(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  IDB *arg1 = (IDB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  (arg1)->BeforeIndexing();
}


SWIGEXPORT void JNICALL Java_IBJNI_IDB_1AfterIndexing(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  IDB *arg1 = (IDB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  (arg1)->AfterIndexing();
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Search_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY arg2 ;
  QUERY const *argp2 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(QUERY **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null QUERY const");
    return 0;
  }
  arg2 = *argp2; 
  result = (IRSET *)(arg1)->Search(arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Search_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jint jarg4) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  SQUERY arg2 ;
  enum SortBy arg3 ;
  enum NormalizationMethods arg4 ;
  SQUERY const *argp2 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(SQUERY **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SQUERY const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = (enum SortBy)jarg3; 
  arg4 = (enum NormalizationMethods)jarg4; 
  result = (IRSET *)(arg1)->Search(arg2,arg3,arg4);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Search_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  SQUERY arg2 ;
  enum SortBy arg3 ;
  SQUERY const *argp2 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(SQUERY **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SQUERY const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = (enum SortBy)jarg3; 
  result = (IRSET *)(arg1)->Search(arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1Search_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  SQUERY arg2 ;
  SQUERY const *argp2 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(SQUERY **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null SQUERY const");
    return 0;
  }
  arg2 = *argp2; 
  result = (IRSET *)(arg1)->Search(arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1SearchSmart_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  char *arg3 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (IRSET *)(arg1)->SearchSmart(arg2,(char const *)arg3);
  *(IRSET **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1SearchSmart_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  result = (IRSET *)(arg1)->SearchSmart(arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1VSearch(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  result = (RSET *)(arg1)->VSearch((QUERY const &)*arg2);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1VSearchSmart_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  char *arg3 = (char *) 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (RSET *)(arg1)->VSearchSmart(arg2,(char const *)arg3);
  *(RSET **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1VSearchSmart_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  result = (RSET *)(arg1)->VSearchSmart(arg2);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Headline_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Headline(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Headline_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Headline(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Summary_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Summary(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Summary_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Summary(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Context_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->Context(arg2,(char const *)arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Context_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Context(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Context_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Context(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1NthContext_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_, jstring jarg4, jstring jarg5) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  RESULT arg3 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  RESULT const *argp3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  argp3 = *(RESULT **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg3 = *argp3; 
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  arg5 = 0;
  if (jarg5) {
    arg5 = (char *)jenv->GetStringUTFChars(jarg5, 0);
    if (!arg5) return 0;
  }
  result = (arg1)->NthContext(arg2,arg3,(char const *)arg4,(char const *)arg5);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  if (arg5) jenv->ReleaseStringUTFChars(jarg5, (const char *)arg5);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1NthContext_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_, jstring jarg4) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  RESULT arg3 ;
  char *arg4 = (char *) 0 ;
  RESULT const *argp3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  argp3 = *(RESULT **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg3 = *argp3; 
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->NthContext(arg2,arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1NthContext_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  unsigned int arg2 ;
  RESULT arg3 ;
  RESULT const *argp3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  argp3 = *(RESULT **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg3 = *argp3; 
  result = (arg1)->NthContext(arg2,arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1URL_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jboolean jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  bool arg3 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = jarg3 ? true : false; 
  result = (arg1)->URL(arg2,arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1URL_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->URL(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1HighlightedRecord(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->HighlightedRecord(arg2,(char const *)arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1DocHighlight_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->DocHighlight(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1DocHighlight_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->DocHighlight(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFieldData_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jlong jarg4, jobject jarg4_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > arg4 ;
  DOCTYPE_ID *argp4 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg4_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  argp4 = *(DOCTYPE_ID **)&jarg4; 
  if (!argp4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DOCTYPE_ID");
    return 0;
  }
  arg4 = *argp4; 
  result = (STRLIST *)IDB_GetFieldData__SWIG_0(arg1,(RESULT const *)arg2,(char const *)arg3,arg4);
  *(STRLIST **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFieldData_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  char *arg3 = (char *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (STRLIST *)IDB_GetFieldData__SWIG_0(arg1,(RESULT const *)arg2,(char const *)arg3);
  *(STRLIST **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFieldContents(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  char *arg3 = (char *) 0 ;
  ArraySTRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = IDB_GetFieldContents(arg1,(RESULT const *)arg2,(char const *)arg3);
  *(ArraySTRING **)&jresult = new ArraySTRING((const ArraySTRING &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Present_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Present(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1Present_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->Present(arg2,(char const *)arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1DocPresent_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->DocPresent(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1DocPresent_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->DocPresent(arg2,(char const *)arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetXMLHighlightRecordFormat_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RESULT const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->GetXMLHighlightRecordFormat((RESULT const &)*arg2,(char const *)arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetXMLHighlightRecordFormat_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RESULT const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->GetXMLHighlightRecordFormat((RESULT const &)*arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_IDB_1GetXMLHighlightRecordFormat_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RESULT const & reference is null");
    return 0;
  } 
  result = (arg1)->GetXMLHighlightRecordFormat((RESULT const &)*arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetNodeOffsetCount_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jstring jarg3, jlong jarg4, jobject jarg4_, jlong jarg5, jobject jarg5_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  char *arg3 = (char *) 0 ;
  FC *arg4 = (FC *) 0 ;
  FC *arg5 = (FC *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg4_;
  (void)jarg5_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE const)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = *(FC **)&jarg4; 
  arg5 = *(FC **)&jarg5; 
  result = (int)(arg1)->GetNodeOffsetCount(arg2,(char const *)arg3,arg4,arg5);
  jresult = (jint)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetNodeOffsetCount_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jstring jarg3, jlong jarg4, jobject jarg4_) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  char *arg3 = (char *) 0 ;
  FC *arg4 = (FC *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg4_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE const)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = *(FC **)&jarg4; 
  result = (int)(arg1)->GetNodeOffsetCount(arg2,(char const *)arg3,arg4);
  jresult = (jint)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetNodeOffsetCount_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jstring jarg3) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE const)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (int)(arg1)->GetNodeOffsetCount(arg2,(char const *)arg3);
  jresult = (jint)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_IDB_1GetNodeOffsetCount_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jint jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  GPTYPE arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  {
    jclass clazz;
    jmethodID mid;
    jbyteArray ba;
    jbyte* bae;
    jsize sz;
    int i;
    
    if (!jarg2) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BigInteger null");
      return 0;
    }
    clazz = jenv->GetObjectClass(jarg2);
    mid = jenv->GetMethodID(clazz, "toByteArray", "()[B");
    ba = (jbyteArray)jenv->CallObjectMethod(jarg2, mid);
    bae = jenv->GetByteArrayElements(ba, 0);
    sz = jenv->GetArrayLength(ba);
    arg2 = 0;
    for(i=0; i<sz; i++) {
      arg2 = (arg2 << 8) | (GPTYPE const)(unsigned char)bae[i];
    }
    jenv->ReleaseByteArrayElements(ba, bae, 0);
  }
  result = (int)(arg1)->GetNodeOffsetCount(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetDescendentsFCT(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  FCT result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(FC **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "FC const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->GetDescendentsFCT((FC const &)*arg2,(char const *)arg3);
  *(FCT **)&jresult = new FCT((const FCT &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetAncestorFc(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  FC result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(FC **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "FC const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->GetAncestorFc((FC const &)*arg2,(char const *)arg3);
  *(FC **)&jresult = new FC((const FC &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetDescendentsContent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jlong jarg4, jobject jarg4_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  FC arg2 ;
  char *arg3 = (char *) 0 ;
  STRLIST *arg4 = (STRLIST *) 0 ;
  FC const *argp2 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg4_;
  arg1 = *(IDB **)&jarg1; 
  argp2 = *(FC **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = *(STRLIST **)&jarg4; 
  result = (arg1)->GetDescendentsContent(arg2,(char const *)arg3,arg4);
  jresult = (jlong)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetAncestorContent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jlong jarg4, jobject jarg4_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  STRLIST *arg4 = (STRLIST *) 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg4_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RESULT & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = *(STRLIST **)&jarg4; 
  result = (arg1)->GetAncestorContent(*arg2,(char const *)arg3,arg4);
  jresult = (jlong)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1KeyLookup(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  RESULT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (RESULT *)IDB_KeyLookup(arg1,arg2);
  *(RESULT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_IDB_1KeyExists(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)IDB_KeyExists(arg1,arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFields_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  STRLIST result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(IDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  result = IDB_GetFields__SWIG_0(arg1,(RESULT const *)arg2);
  *(STRLIST **)&jresult = new STRLIST((const STRLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_IDB_1GetFields_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  IDB *arg1 = (IDB *) 0 ;
  STRLIST result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(IDB **)&jarg1; 
  result = IDB_GetFields__SWIG_0(arg1);
  *(STRLIST **)&jresult = new STRLIST((const STRLIST &)result); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1IDB(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  IDB *arg1 = (IDB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(IDB **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1VIDB_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  VIDB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (VIDB *)new VIDB();
  *(VIDB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1VIDB_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jstring jarg1, jboolean jarg2) {
  jlong jresult = 0 ;
  STRING arg1 ;
  bool arg2 ;
  VIDB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  arg2 = jarg2 ? true : false; 
  result = (VIDB *)new VIDB(arg1,arg2);
  *(VIDB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1VIDB(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  VIDB *arg1 = (VIDB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(VIDB **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1getself(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  VIDB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  {
    VIDB &_result_ref = VIDB_getself(arg1);
    result = (VIDB *) &_result_ref;
  }
  *(VIDB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetIDB_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  IDB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (IDB *)VIDB_GetIDB__SWIG_0(arg1,arg2);
  *(IDB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetIDB_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  IDB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (IDB *)VIDB_GetIDB__SWIG_0(arg1);
  *(IDB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetIDBCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (unsigned int)((VIDB const *)arg1)->GetIDBCount();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1IsDbVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (bool)((VIDB const *)arg1)->IsDbVirtual();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetMainMdt_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  MDT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (MDT *)((VIDB const *)arg1)->GetMainMdt();
  *(MDT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetMainMdt_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  MDT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (MDT *)((VIDB const *)arg1)->GetMainMdt(arg2);
  *(MDT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetFieldCache_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  FCACHE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (FCACHE *)(arg1)->GetFieldCache();
  *(FCACHE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetFieldCache_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  FCACHE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (FCACHE *)(arg1)->GetFieldCache(arg2);
  *(FCACHE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetDocTypeOptions(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  ArraySTRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = VIDB_GetDocTypeOptions((VIDB const *)arg1);
  *(ArraySTRING **)&jresult = new ArraySTRING((const ArraySTRING &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetDbFileStem_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = ((VIDB const *)arg1)->GetDbFileStem(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetDbFileStem_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = ((VIDB const *)arg1)->GetDbFileStem();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1XMLHitTable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT *arg2 = 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RESULT const & reference is null");
    return 0;
  } 
  result = (arg1)->XMLHitTable((RESULT const &)*arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1XMLNodeTree(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  FC arg3 ;
  RESULT const *argp2 ;
  FC *argp3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  argp3 = *(FC **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null FC");
    return 0;
  }
  arg3 = *argp3; 
  result = (arg1)->XMLNodeTree(arg2,arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetPriorityFactor_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2, jlong jarg3) {
  VIDB *arg1 = (VIDB *) 0 ;
  double arg2 ;
  unsigned int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (double)jarg2; 
  arg3 = (unsigned int)jarg3; 
  (arg1)->SetPriorityFactor(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetPriorityFactor_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  double arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (double)jarg2; 
  (arg1)->SetPriorityFactor(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetDbSearchCutoff_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (unsigned int)jarg3; 
  (arg1)->SetDbSearchCutoff(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetDbSearchCutoff_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDbSearchCutoff(arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetDbSearchCutoff(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (unsigned int)(arg1)->GetDbSearchCutoff();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetDbSearchFuel_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (unsigned int)jarg3; 
  (arg1)->SetDbSearchFuel(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetDbSearchFuel_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDbSearchFuel(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetDbSearchCacheSize_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (unsigned int)jarg3; 
  (arg1)->SetDbSearchCacheSize(arg2,arg3);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetDbSearchCacheSize_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->SetDbSearchCacheSize(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1BeforeSearching(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  (arg1)->BeforeSearching(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetDebugMode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  (arg1)->SetDebugMode(arg2);
}


SWIGEXPORT jint JNICALL Java_IBJNI_VIDB_1GetErrorCode_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (int)(arg1)->GetErrorCode(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_VIDB_1GetErrorCode_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (int)(arg1)->GetErrorCode();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1ErrorMessage_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (char *)((VIDB const *)arg1)->ErrorMessage(arg2);
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1ErrorMessage_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (char *)((VIDB const *)arg1)->ErrorMessage();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_VIDB_1GetTotalWords_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (long)(arg1)->GetTotalWords(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_VIDB_1GetTotalWords_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (long)(arg1)->GetTotalWords();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_VIDB_1GetTotalUniqueWords_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (long)(arg1)->GetTotalUniqueWords(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_VIDB_1GetTotalUniqueWords_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (long)(arg1)->GetTotalUniqueWords();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetTotalRecords_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (unsigned int)(arg1)->GetTotalRecords(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetTotalRecords_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalRecords();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetTotalDocumentsDeleted_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (unsigned int)(arg1)->GetTotalDocumentsDeleted(arg2);
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetTotalDocumentsDeleted_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalDocumentsDeleted();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetTotalDatabases(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (unsigned int)(arg1)->GetTotalDatabases();
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1IsDbCompatible(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (bool)(arg1)->IsDbCompatible();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1IsEmpty(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (bool)((VIDB const *)arg1)->IsEmpty();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1Ok(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (bool)(arg1)->Ok();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetCommonWordsThreshold(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  long arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (long)jarg2; 
  (arg1)->SetCommonWordsThreshold(arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1SetStoplist(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return ;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return ; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return ;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  (arg1)->SetStoplist(arg2);
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1IsStopWord(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->IsStopWord(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetTitle_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->GetTitle(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetTitle_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->GetTitle();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetComments_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->GetComments(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetComments_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->GetComments();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetMaintainer_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->GetMaintainer(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetMaintainer_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->GetMaintainer();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1SearchSmart_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  char *arg3 = (char *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (IRSET *)(arg1)->SearchSmart(arg2,(char const *)arg3);
  *(IRSET **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1SearchSmart_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  result = (IRSET *)(arg1)->SearchSmart(arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1Search_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  result = (IRSET *)(arg1)->Search((QUERY const &)*arg2);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1Search_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = 0 ;
  VIDB_STATS *arg3 = (VIDB_STATS *) 0 ;
  IRSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg3_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  arg3 = *(VIDB_STATS **)&jarg3; 
  result = (IRSET *)(arg1)->Search((QUERY const &)*arg2,arg3);
  *(IRSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1VSearch(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  result = (RSET *)(arg1)->VSearch((QUERY const &)*arg2);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1VSearchSmart_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  char *arg3 = (char *) 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (RSET *)(arg1)->VSearchSmart(arg2,(char const *)arg3);
  *(RSET **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1VSearchSmart_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = (QUERY *) 0 ;
  RSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2; 
  result = (RSET *)(arg1)->VSearchSmart(arg2);
  *(RSET **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1Scan_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((VIDB const *)arg1)->Scan(arg2);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1Scan_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  int arg3 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = (int)jarg3; 
  result = (arg1)->Scan(arg2,arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1Scan_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Scan(arg2,(char const *)arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1Scan_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jint jarg4) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (int)jarg4; 
  result = (arg1)->Scan(arg2,(char const *)arg3,arg4);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1ScanGlob_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->ScanGlob(arg2);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1ScanGlob_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  INT arg3 ;
  INT const *argp3 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  argp3 = *(INT **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null INT const");
    return 0;
  }
  arg3 = *argp3; 
  result = (arg1)->ScanGlob(arg2,arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1ScanGlob_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->ScanGlob(arg2,(char const *)arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1ScanGlob_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jlong jarg4) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  char *arg3 = (char *) 0 ;
  INT arg4 ;
  INT const *argp4 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  argp4 = *(INT **)&jarg4; 
  if (!argp4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null INT const");
    return 0;
  }
  arg4 = *argp4; 
  result = (arg1)->ScanGlob(arg2,(char const *)arg3,arg4);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1ScanSearch_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->ScanSearch((QUERY const &)*arg2,(char const *)arg3);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1ScanSearch_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jlong jarg4) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  QUERY *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  size_t arg4 ;
  SwigValueWrapper< SCANLIST > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(QUERY **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "QUERY const & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = (size_t)jarg4; 
  result = (arg1)->ScanSearch((QUERY const &)*arg2,(char const *)arg3,arg4);
  *(SCANLIST **)&jresult = new SCANLIST((const SCANLIST &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1BeginRsetPresent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->BeginRsetPresent((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetAncestorContent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jlong jarg4, jobject jarg4_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  STRLIST *arg4 = (STRLIST *) 0 ;
  size_t result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg4_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2;
  if(!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "RESULT & reference is null");
    return 0;
  } 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = *(STRLIST **)&jarg4; 
  result = (arg1)->GetAncestorContent(*arg2,(char const *)arg3,arg4);
  jresult = (jlong)result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Headline_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Headline(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Headline_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Headline(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Summary_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Summary(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Summary_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Summary(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Context_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  STRING arg3 ;
  STRING arg4 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg4/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg4/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      rtn[size] = 0;
      arg4 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg4 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4_pstr) return 0;
    arg4 =  STRING(arg4_pstr);
    jenv->ReleaseStringUTFChars(jarg4, arg4_pstr);
    
  }
#endif
  
  result = (arg1)->Context(arg2,arg3,arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Context_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->Context(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1NthContext_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  RESULT arg3 ;
  RESULT const *argp3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  argp3 = *(RESULT **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg3 = *argp3; 
  result = (arg1)->NthContext(arg2,arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1NthContext_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3, jobject jarg3_, jstring jarg4, jstring jarg5) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  unsigned int arg2 ;
  RESULT arg3 ;
  STRING arg4 ;
  STRING arg5 ;
  RESULT const *argp3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  argp3 = *(RESULT **)&jarg3; 
  if (!argp3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg3 = *argp3; 
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg4/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg4/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      rtn[size] = 0;
      arg4 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg4 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4_pstr) return 0;
    arg4 =  STRING(arg4_pstr);
    jenv->ReleaseStringUTFChars(jarg4, arg4_pstr);
    
  }
#endif
  
  if(!jarg5) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg5/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg5/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg5/*jstr*/, jcstr);
      rtn[size] = 0;
      arg5 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg5/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg5 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg5_pstr = (const char *)jenv->GetStringUTFChars(jarg5, 0);
    if (!arg5_pstr) return 0;
    arg5 =  STRING(arg5_pstr);
    jenv->ReleaseStringUTFChars(jarg5, arg5_pstr);
    
  }
#endif
  
  result = (arg1)->NthContext(arg2,arg3,arg4,arg5);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1URL_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jboolean jarg3) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  bool arg3 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = jarg3 ? true : false; 
  result = (arg1)->URL(arg2,arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1URL_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->URL(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1HighlightedRecord(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  STRING arg3 ;
  STRING arg4 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg4/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg4/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      rtn[size] = 0;
      arg4 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg4 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4_pstr) return 0;
    arg4 =  STRING(arg4_pstr);
    jenv->ReleaseStringUTFChars(jarg4, arg4_pstr);
    
  }
#endif
  
  result = (arg1)->HighlightedRecord(arg2,arg3,arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1DocHighlight_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->DocHighlight(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1DocHighlight_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->DocHighlight(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetFieldData_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jlong jarg4, jobject jarg4_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  char *arg3 = (char *) 0 ;
  SwigValueWrapper< DOCTYPE_ID > arg4 ;
  DOCTYPE_ID *argp4 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  (void)jarg4_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  argp4 = *(DOCTYPE_ID **)&jarg4; 
  if (!argp4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DOCTYPE_ID");
    return 0;
  }
  arg4 = *argp4; 
  result = (STRLIST *)VIDB_GetFieldData__SWIG_0(arg1,(RESULT const *)arg2,(char const *)arg3,arg4);
  *(STRLIST **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetFieldData_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  char *arg3 = (char *) 0 ;
  STRLIST *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (STRLIST *)VIDB_GetFieldData__SWIG_0(arg1,(RESULT const *)arg2,(char const *)arg3);
  *(STRLIST **)&jresult = result; 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetFieldContents(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  char *arg3 = (char *) 0 ;
  ArraySTRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = VIDB_GetFieldContents(arg1,(RESULT const *)arg2,(char const *)arg3);
  *(ArraySTRING **)&jresult = new ArraySTRING((const ArraySTRING &)result); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Present_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->Present(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1Present_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->Present(arg2,(char const *)arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1DocPresent_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (arg1)->DocPresent(arg2,(char const *)arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1DocPresent_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  RESULT const *argp2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(RESULT **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null RESULT const");
    return 0;
  }
  arg2 = *argp2; 
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  arg4 = 0;
  if (jarg4) {
    arg4 = (char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4) return 0;
  }
  result = (arg1)->DocPresent(arg2,(char const *)arg3,(char const *)arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  if (arg4) jenv->ReleaseStringUTFChars(jarg4, (const char *)arg4);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_VIDB_1EndRsetPresent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  VIDB *arg1 = (VIDB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->EndRsetPresent((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetGlobalDocType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->GetGlobalDocType();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1KeyLookup(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  RESULT *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (RESULT *)VIDB_KeyLookup(arg1,arg2);
  *(RESULT **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1KeyExists(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)VIDB_KeyExists(arg1,arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1SetDateRange(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  SwigValueWrapper< DATERANGE > arg2 ;
  DATERANGE const *argp2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  argp2 = *(DATERANGE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null DATERANGE const");
    return 0;
  }
  arg2 = *argp2; 
  result = (bool)(arg1)->SetDateRange(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1ProfileGetString_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jstring jarg4) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  STRING arg4 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg4/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg4/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      rtn[size] = 0;
      arg4 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg4/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg4 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0);
    if (!arg4_pstr) return 0;
    arg4 =  STRING(arg4_pstr);
    jenv->ReleaseStringUTFChars(jarg4, arg4_pstr);
    
  }
#endif
  
  result = (arg1)->ProfileGetString(arg2,arg3,arg4);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1ProfileGetString_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  result = (arg1)->ProfileGetString(arg2,arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1FirstKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->FirstKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1LastKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->LastKey();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1NextKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->NextKey(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1PrevKey(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->PrevKey(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1GetDocumentInfo(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3, jlong jarg4, jobject jarg4_) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int arg2 ;
  int arg3 ;
  RECORD *arg4 = (RECORD *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg4_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = *(RECORD **)&jarg4; 
  result = (bool)(arg1)->GetDocumentInfo(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1DateCreated(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->DateCreated();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1DateLastModified(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  SRCH_DATE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->DateLastModified();
  *(SRCH_DATE **)&jresult = new SRCH_DATE((const SRCH_DATE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetAllDocTypes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRLIST result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->GetAllDocTypes();
  *(STRLIST **)&jresult = new STRLIST((const STRLIST &)result); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_VIDB_1ValidateDocType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (bool)(arg1)->ValidateDocType((char const *)arg2);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_VIDB_1GetVersionID(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (arg1)->GetVersionID();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_VIDB_1GetLocks(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = (int)(arg1)->GetLocks();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetFields_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  RESULT *arg2 = (RESULT *) 0 ;
  ArraySTRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(VIDB **)&jarg1; 
  arg2 = *(RESULT **)&jarg2; 
  result = VIDB_GetFields__SWIG_0(arg1,(RESULT const *)arg2);
  *(ArraySTRING **)&jresult = new ArraySTRING((const ArraySTRING &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_VIDB_1GetFields_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  VIDB *arg1 = (VIDB *) 0 ;
  ArraySTRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(VIDB **)&jarg1; 
  result = VIDB_GetFields__SWIG_0(arg1);
  *(ArraySTRING **)&jresult = new ArraySTRING((const ArraySTRING &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1LANGUAGE(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  LANGUAGE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  result = (LANGUAGE *)new LANGUAGE((char const *)arg1);
  *(LANGUAGE **)&jresult = result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_LANGUAGE_1Name(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  LANGUAGE *arg1 = (LANGUAGE *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LANGUAGE **)&jarg1; 
  result = (char *)((LANGUAGE const *)arg1)->Name();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_LANGUAGE_1Code(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  LANGUAGE *arg1 = (LANGUAGE *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LANGUAGE **)&jarg1; 
  result = (char *)((LANGUAGE const *)arg1)->Code();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1LANGUAGE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  LANGUAGE *arg1 = (LANGUAGE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(LANGUAGE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1CHARSET(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  char *arg1 = (char *) 0 ;
  CHARSET *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  result = (CHARSET *)new CHARSET((char const *)arg1);
  *(CHARSET **)&jresult = result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_CHARSET_1Ok(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  result = (bool)((CHARSET const *)arg1)->Ok();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_CHARSET_1Name(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  result = (char *)CHARSET_Name((CHARSET const *)arg1);
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_CHARSET_1HtmlCat_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  jstring jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  STRING arg2 ;
  bool arg3 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  arg3 = jarg3 ? true : false; 
  result = ((CHARSET const *)arg1)->HtmlCat(arg2,arg3);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_CHARSET_1HtmlCat_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((CHARSET const *)arg1)->HtmlCat(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_CHARSET_1ToLower(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((CHARSET const *)arg1)->ToLower(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_CHARSET_1ToUpper(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = ((CHARSET const *)arg1)->ToUpper(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isalpha(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isalpha(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isupper(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isupper(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1islower(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_islower(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isdigit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isdigit(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isxdigit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isxdigit(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isalnum(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isalnum(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isspace(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isspace(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1ispunct(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_ispunct(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isprint(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isprint(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isgraph(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isgraph(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1iscntrl(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_iscntrl(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1iswhite(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_iswhite(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1isascii(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_isascii(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1islatin1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_islatin1(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1toupper(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_toupper(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1tolower(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_tolower(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1ib_1toascii(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->ib_toascii(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1isTermChr(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->isTermChr(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1isWordSep(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->isWordSep(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1isTermWhite(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)((CHARSET const *)arg1)->isTermWhite(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_CHARSET_1UCS(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jchar jarg2) {
  jint jresult = 0 ;
  CHARSET *arg1 = (CHARSET *) 0 ;
  char arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(CHARSET **)&jarg1; 
  arg2 = (char)jarg2; 
  result = (int)CHARSET_UCS(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1CHARSET(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  CHARSET *arg1 = (CHARSET *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(CHARSET **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1LOCALE(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  LOCALE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (LOCALE *)new LOCALE();
  *(LOCALE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1LOCALE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  LOCALE *arg1 = (LOCALE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(LOCALE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_LOCALE_1SetLanguage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  SwigValueWrapper< LANGUAGE > arg2 ;
  LANGUAGE *argp2 ;
  LOCALE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(LOCALE **)&jarg1; 
  argp2 = *(LANGUAGE **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null LANGUAGE");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->SetLanguage(arg2);
  *(LOCALE **)&jresult = new LOCALE((const LOCALE &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_LOCALE_1SetCharset(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  SwigValueWrapper< CHARSET > arg2 ;
  CHARSET *argp2 ;
  LOCALE result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(LOCALE **)&jarg1; 
  argp2 = *(CHARSET **)&jarg2; 
  if (!argp2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null CHARSET");
    return 0;
  }
  arg2 = *argp2; 
  result = (arg1)->SetCharset(arg2);
  *(LOCALE **)&jresult = new LOCALE((const LOCALE &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_LOCALE_1GetLanguageCode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = (char *)((LOCALE const *)arg1)->GetLanguageCode();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_LOCALE_1GetLanguageName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = (char *)((LOCALE const *)arg1)->GetLanguageName();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_LOCALE_1GetCharsetCode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = (char *)((LOCALE const *)arg1)->GetCharsetCode();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_LOCALE_1GetCharsetName(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = (char *)((LOCALE const *)arg1)->GetCharsetName();
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_LOCALE_1Charset(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  SwigValueWrapper< CHARSET > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = ((LOCALE const *)arg1)->Charset();
  *(CHARSET **)&jresult = new CHARSET((const CHARSET &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_LOCALE_1Language(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  SwigValueWrapper< LANGUAGE > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = ((LOCALE const *)arg1)->Language();
  *(LANGUAGE **)&jresult = new LANGUAGE((const LANGUAGE &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_LOCALE_1Name(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = LOCALE_Name((LOCALE const *)arg1);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOCALE_1Id(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  LOCALE *arg1 = (LOCALE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(LOCALE **)&jarg1; 
  result = (int)((LOCALE const *)arg1)->Id();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ResolveConfigPath(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jstring jresult = 0 ;
  STRING arg1 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = ResolveConfigPath(arg1);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ResolveBinPath(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jstring jresult = 0 ;
  STRING arg1 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = ResolveBinPath(arg1);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_ExpandFileSpec(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jstring jresult = 0 ;
  STRING arg1 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = ExpandFileSpec(arg1);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1PANIC_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 0);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1FATAL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 1);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1ERROR_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1ERRNO_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1WARN_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 4);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1NOTICE_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 5);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1INFO_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 6);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1DEBUG_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) (1 << 7);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_LOG_1ALL_1get(JNIEnv *jenv, jclass jcls) {
  jint jresult = 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  result = (int) 0xffff;
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1STDERR_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<stderr>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1STDOUT_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<stdout>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1SYSLOG_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL0_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog0>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL1_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog1>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL2_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog2>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL3_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog3>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL4_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog4>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL5_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog5>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL6_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog6>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_DEVICE_1LOCAL7_1get(JNIEnv *jenv, jclass jcls) {
  jstring jresult = 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (char *) "<syslog7>";
  if(result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_set_1syslog(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jboolean jresult = 0 ;
  char *arg1 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  arg1 = 0;
  if (jarg1) {
    arg1 = (char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1) return 0;
  }
  result = (bool)set_syslog((char const *)arg1);
  jresult = (jboolean)result; 
  if (arg1) jenv->ReleaseStringUTFChars(jarg1, (const char *)arg1);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_log_1init_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1, jstring jarg2, jstring jarg3) {
  jboolean jresult = 0 ;
  int arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  arg3 = 0;
  if (jarg3) {
    arg3 = (char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3) return 0;
  }
  result = (bool)log_init(arg1,(char const *)arg2,(char const *)arg3);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  if (arg3) jenv->ReleaseStringUTFChars(jarg3, (const char *)arg3);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_log_1init_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jint jarg1, jstring jarg2) {
  jboolean jresult = 0 ;
  int arg1 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return 0;
  }
  result = (bool)log_init(arg1,(char const *)arg2);
  jresult = (jboolean)result; 
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_log_1init_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jboolean jresult = 0 ;
  int arg1 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (bool)log_init(arg1);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_log_1message(JNIEnv *jenv, jclass jcls, jint jarg1, jstring jarg2) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  log_message(arg1,(char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1INODE_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  INODE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (INODE *)new INODE();
  *(INODE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1INODE_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jstring jarg1) {
  jlong jresult = 0 ;
  STRING arg1 ;
  INODE *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  if(!jarg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg1/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg1/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      rtn[size] = 0;
      arg1 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg1/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg1 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg1_pstr = (const char *)jenv->GetStringUTFChars(jarg1, 0);
    if (!arg1_pstr) return 0;
    arg1 =  STRING(arg1_pstr);
    jenv->ReleaseStringUTFChars(jarg1, arg1_pstr);
    
  }
#endif
  
  result = (INODE *)new INODE(arg1);
  *(INODE **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_INODE_1Clear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  INODE *arg1 = (INODE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  (arg1)->Clear();
}


SWIGEXPORT jlong JNICALL Java_IBJNI_INODE_1Set_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  STRING arg2 ;
  GDT_BOOLEAN result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->Set(arg2);
  *(GDT_BOOLEAN **)&jresult = new GDT_BOOLEAN((const GDT_BOOLEAN &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_INODE_1Set_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  GDT_BOOLEAN result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  arg2 = *(FILE **)&jarg2; 
  result = (arg1)->Set(arg2);
  *(GDT_BOOLEAN **)&jresult = new GDT_BOOLEAN((const GDT_BOOLEAN &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_INODE_1Set_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  int arg2 ;
  GDT_BOOLEAN result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->Set(arg2);
  *(GDT_BOOLEAN **)&jresult = new GDT_BOOLEAN((const GDT_BOOLEAN &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI_INODE_1Key(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  result = ((INODE const *)arg1)->Key();
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_INODE_1isLinked(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  result = (bool)((INODE const *)arg1)->isLinked();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI_INODE_1isDangling(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  result = (bool)((INODE const *)arg1)->isDangling();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_INODE_1inode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  result = (int)((INODE const *)arg1)->inode();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI_INODE_1device(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  INODE *arg1 = (INODE *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(INODE **)&jarg1; 
  result = (int)((INODE const *)arg1)->device();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1INODE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  INODE *arg1 = (INODE *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(INODE **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jint JNICALL Java_IBJNI__1_1IB_1GetFreeMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  result = (long)(arg1)->GetFreeMemory();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI__1_1IB_1GetTotalMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  result = (long)(arg1)->GetTotalMemory();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI__1_1IB_1Hostid(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  result = (long)(arg1)->Hostid();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI__1_1IB_1SerialID(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  long result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  result = (long)(arg1)->SerialID();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI__1_1IB_1FileGlob(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jboolean jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->FileGlob(arg2,arg3);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI__1_1IB_1Glob_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jboolean jarg4) {
  jboolean jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  bool arg4 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  arg4 = jarg4 ? true : false; 
  result = (bool)(arg1)->Glob(arg2,arg3,arg4);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI__1_1IB_1Glob_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jboolean jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->Glob(arg2,arg3);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_IBJNI__1_1IB_1GetUserHome(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  STRING result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (arg1)->GetUserHome(arg2);
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI__1_1IB_1DirectoryExists(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->DirectoryExists(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI__1_1IB_1FileExists(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->FileExists(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_IBJNI__1_1IB_1ExeExists(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jboolean jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  result = (bool)(arg1)->ExeExists(arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_IBJNI__1_1IB_1FileLink(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jint jresult = 0 ;
  __IB *arg1 = (__IB *) 0 ;
  STRING arg2 ;
  STRING arg3 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg2/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg2/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      rtn[size] = 0;
      arg2 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg2/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg2 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2_pstr) return 0;
    arg2 =  STRING(arg2_pstr);
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr);
    
  }
#endif
  
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null STRING");
    return 0;
  }
#if defined(_MSDOS) || defined(_WIN32) || defined(WIN32)
  {
    int length = jenv->GetStringLength(jarg3/*jstr*/);
    const jchar* jcstr = jenv->GetStringChars(jarg3/*jstr*/, 0 );
    int size   = 0;
    int maxLen = length*3 + 1;
    
#ifdef __GNUG__
    char rtn[ maxLen];
#elif defined(NO_ALLOCA)
    char* rtn = (char*)malloc( maxLen );
#else
    char *rtn = (char *)alloca( maxLen );
#endif
    memset(rtn, '\0', maxLen);
    
    /* Microsoft says:
    "Security Alert   Using the WideCharToMultiByte function incorrectly can compromise the
    security of your application. Calling this function can easily cause a buffer overrun
    because the size of the input buffer indicated by lpWideCharStr equals the number of
    WCHAR values in the string, while the size of the output buffer indicated by lpMultiByteStr
    equals the number of bytes. To avoid a buffer overrun, your application must specify a
    buffer size appropriate for the data type the buffer receives.  "
    */
    // WIN32API: WideCharToMultiByte
    // UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr,
    // int cbMultiByte, LPCSTR lpDefaultChar,    LPBOOL lpUsedDefaultChar
    // CP_ACP := The current system Windows ANSI code page. This value can be different on
    // different computers, even on the same network. It can be changed on the same computer,
    // leading to stored data becoming irrecoverably corrupted.
    if ((size = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)jcstr, length, rtn, maxLen, NULL, NULL )) > 0)
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      rtn[size] = 0;
      arg3 = rtn;
    }
    else
    {
      jenv->ReleaseStringChars(jarg3/*jstr*/, jcstr);
      size = 0;
      rtn[size] = 0;
      arg3 = rtn;
    }
#if !defined( __GNUG__) && defined(NO_ALLOCA)
    free(rtn);
#endif
    if (rtn[0] == 0) return 0; // Empty string
  }
#else
  {
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0);
    if (!arg3_pstr) return 0;
    arg3 =  STRING(arg3_pstr);
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr);
    
  }
#endif
  
  result = (int)(arg1)->FileLink(arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendDebugMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendDebugMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendInfoMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendInfoMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendNoticeMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendNoticeMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendWarningMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendWarningMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendErrorMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendErrorMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendErrnoMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendErrnoMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendFatalMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendFatalMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT void JNICALL Java_IBJNI__1_1IB_1SendPanicMessage(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  __IB *arg1 = (__IB *) 0 ;
  char *arg2 = (char *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(__IB **)&jarg1; 
  arg2 = 0;
  if (jarg2) {
    arg2 = (char *)jenv->GetStringUTFChars(jarg2, 0);
    if (!arg2) return ;
  }
  (arg1)->SendPanicMessage((char const *)arg2);
  if (arg2) jenv->ReleaseStringUTFChars(jarg2, (const char *)arg2);
}


SWIGEXPORT jlong JNICALL Java_IBJNI_new_1_1_1IB(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  __IB *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (__IB *)new __IB();
  *(__IB **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_IBJNI_delete_1_1_1IB(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  __IB *arg1 = (__IB *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(__IB **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_IBJNI_SWIGIDBUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(IDBOBJ **)&baseptr = *(IDB **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_IBJNI_SWIGVIDBUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(IDBOBJ **)&baseptr = *(VIDB **)&jarg1;
    return baseptr;
}

#ifdef __cplusplus
}
#endif

